{"version":3,"file":"static/js/387.49fbd0c3.chunk.js","mappings":"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","sources":["../../components/src/difftable.tsx","../../simulator/src/chip/chip.tsx","../../simulator/src/chip/clock.ts","../../simulator/src/cpu/alu.ts","../../simulator/src/cpu/cpu.ts","../../simulator/src/cpu/memory.ts","../../simulator/src/fs.ts","../../simulator/src/languages/grammars/base.ohm.js","../../simulator/src/languages/base.ts","../../simulator/src/languages/grammars/cmp.ohm.js","../../simulator/src/languages/cmp.ts","../../simulator/src/languages/grammars/tst.ohm.js","../../simulator/src/languages/tst.ts","../../simulator/src/languages/grammars/asm.ohm.js","../../simulator/src/languages/asm.ts","../../simulator/src/loader.ts","../../simulator/src/output.ts","../../simulator/src/tst.ts","../../simulator/src/util/asm.ts","../../simulator/src/util/twos.ts"],"sourcesContent":["import { CMP } from \"@nand2tetris/simulator/languages/cmp.js\";\nimport { display } from \"@davidsouther/jiffies/lib/esm/display.js\";\nimport { range } from \"@davidsouther/jiffies/lib/esm/range.js\";\nimport { Err, isErr, Ok } from \"@davidsouther/jiffies/lib/esm/result.js\";\nimport { ReactElement } from \"react\";\n\nexport const DiffTable = ({\n  className = \"\",\n  out,\n  cmp,\n  zeroState,\n}: {\n  out: string;\n  cmp: string;\n  className?: string;\n  zeroState?: ReactElement;\n}) => {\n  const output = CMP.parse(out);\n  const compare = CMP.parse(cmp);\n\n  if (isErr(output)) {\n    return (\n      <details>\n        <summary>Failed to parse output</summary>\n        <pre>{display(Err(output))}</pre>\n        <code>\n          <pre>{out}</pre>\n        </code>\n      </details>\n    );\n  }\n\n  if (isErr(compare)) {\n    return (\n      <details>\n        <summary>Failed to parse compare</summary>\n        <code>\n          <pre>{display(Err(compare))}</pre>\n          <pre>{cmp}</pre>\n        </code>\n      </details>\n    );\n  }\n\n  const cmpData = Ok(compare);\n  const outData = Ok(output);\n  let failures = 0;\n  const table = range(0, Math.min(cmpData.length, outData.length)).map((i) => {\n    const cmpI = cmpData[i] ?? [];\n    const outI = outData[i] ?? [];\n    return range(0, Math.max(cmpI.length, outI.length))\n      .map((_, j) => [cmpI[j] ?? \"\", outI[j] ?? \"\"])\n      .map(([cmp, out]) => {\n        const cell = {\n          cmp: cmp ?? '\"',\n          out: out ?? '\"',\n          pass:\n            cmp?.trim().match(/^\\*+$/) !== null || out?.trim() === cmp?.trim(),\n        };\n        if (!cell.pass) {\n          failures += 1;\n        }\n        return cell;\n      });\n  });\n\n  return (\n    <div className={\"scroll-x \" + className}>\n      {failures > 0 && (\n        <p>\n          {failures} failure{failures === 1 ? \"\" : \"s\"}\n        </p>\n      )}\n      {table.length > 0 ? (\n        <table\n          style={{\n            fontFamily: \"var(--font-family-monospace)\",\n            marginBottom: \"none\",\n          }}\n        >\n          <tbody>\n            {table.map((row, i) => (\n              <tr key={i}>\n                {row.map(({ cmp, out, pass }, i) => (\n                  <DiffCell cmp={cmp} out={out} pass={pass} key={i} />\n                ))}\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      ) : (\n        zeroState ?? <p>Execute test script to compare output.</p>\n      )}\n    </div>\n  );\n};\n\nconst DiffCell = ({\n  cmp,\n  out,\n  pass,\n}: {\n  cmp: string;\n  out: string;\n  pass: boolean;\n}) => {\n  return pass ? (\n    <>\n      <td>{cmp}</td>\n    </>\n  ) : (\n    <>\n      <td>\n        <ins>{cmp}</ins>\n        <br />\n        <del>{out}</del>\n      </td>\n    </>\n  );\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { assert, assertExists } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport { range } from \"@davidsouther/jiffies/lib/esm/range.js\";\nimport { bin } from \"../util/twos.js\";\nimport { Clock } from \"./clock.js\";\n\nexport const HIGH = 1;\nexport const LOW = 0;\nexport type Voltage = typeof HIGH | typeof LOW;\n\nexport interface Pin {\n  readonly name: string;\n  readonly width: number;\n  busVoltage: number;\n  pull(voltage: Voltage, bit?: number): void;\n  toggle(bit?: number): void;\n  voltage(bit?: number): Voltage;\n  connect(pin: Pin): void;\n}\n\nexport class Bus implements Pin {\n  state: Voltage[];\n  next: Pin[] = [];\n\n  constructor(readonly name: string, readonly width = 1) {\n    this.state = range(0, this.width).map(() => LOW);\n  }\n\n  ensureWidth(newWidth: number) {\n    assert(newWidth <= 16, `Cannot widen past 16 to ${newWidth} bits`);\n    if (this.width < newWidth) {\n      (this as { width: number }).width = newWidth;\n      this.state = [\n        ...this.state,\n        ...range(this.width, newWidth).map(() => LOW as Voltage),\n      ];\n    }\n  }\n\n  connect(next: Pin) {\n    this.next.push(next);\n    next.busVoltage = this.busVoltage;\n  }\n\n  pull(voltage: Voltage, bit = 0) {\n    assert(\n      bit >= 0 && bit < this.width,\n      `Bit out of bounds: ${this.name}@${bit}`\n    );\n    this.state[bit] = voltage;\n    this.next.forEach((n) => n.pull(voltage, bit));\n  }\n\n  voltage(bit = 0): Voltage {\n    assert(bit >= 0 && bit < this.width);\n    return this.state[bit];\n  }\n\n  set busVoltage(voltage: number) {\n    for (const i of range(0, this.width)) {\n      this.state[i] = ((voltage & (1 << i)) >> i) as Voltage;\n    }\n    this.next.forEach((n) => (n.busVoltage = this.busVoltage));\n  }\n\n  get busVoltage(): number {\n    return range(0, this.width).reduce((b, i) => b | (this.state[i] << i), 0);\n  }\n\n  toggle(bit = 0) {\n    const nextVoltage = this.voltage(bit) === LOW ? HIGH : LOW;\n    this.pull(nextVoltage, bit);\n  }\n}\n\nexport class InSubBus extends Bus {\n  constructor(\n    private bus: Pin,\n    private start: number,\n    override readonly width = 1\n  ) {\n    super(bus.name);\n    assert(\n      start >= 0 && start + width <= bus.width,\n      `Mismatched InSubBus dimensions on ${bus.name} (${width} + ${start} > ${bus.width})`\n    );\n    this.connect(bus);\n  }\n\n  override pull(voltage: Voltage, bit = 0) {\n    assert(bit >= 0 && bit < this.width);\n    this.bus.pull(voltage, this.start + bit);\n  }\n\n  override voltage(bit = 0): Voltage {\n    assert(bit >= 0 && bit < this.width);\n    return this.bus.voltage(this.start + bit);\n  }\n\n  override set busVoltage(voltage: number) {\n    const high = this.bus.busVoltage & ~mask(this.width + this.start);\n    const low = this.bus.busVoltage & mask(this.start);\n    const mid = (voltage & mask(this.width)) << this.start;\n    this.bus.busVoltage = high | mid | low;\n  }\n\n  override get busVoltage(): number {\n    return (this.bus.busVoltage >> this.start) & mask(this.width);\n  }\n\n  override connect(bus: Pin): void {\n    assert(\n      this.start + this.width <= bus.width,\n      `Mismatched InSubBus connection dimensions (From ${bus.name} to ${this.name})`\n    );\n    this.bus = bus;\n  }\n}\n\nexport class OutSubBus extends Bus {\n  constructor(\n    private bus: Pin,\n    private start: number,\n    override readonly width = 1\n  ) {\n    super(bus.name);\n    assert(start >= 0 && width <= bus.width, `Mismatched OutSubBus dimensions`);\n    this.connect(bus);\n  }\n\n  override set busVoltage(voltage: number) {\n    this.bus.busVoltage =\n      (voltage & mask(this.width + this.start)) >> this.start;\n  }\n\n  override get busVoltage(): number {\n    return this.bus.busVoltage & mask(this.width);\n  }\n\n  override connect(bus: Pin): void {\n    assert(\n      this.width <= bus.width,\n      `Mismatched OutSubBus connection dimensions`\n    );\n    this.bus = bus;\n  }\n}\n\nexport class ConstantBus extends Bus {\n  constructor(name: string, private readonly value: number) {\n    super(name, 16 /* TODO: get high bit index */);\n  }\n\n  pullHigh(_ = 0) {\n    return undefined;\n  }\n  pullLow(_ = 0) {\n    return undefined;\n  }\n  override voltage(_ = 0): Voltage {\n    return (this.busVoltage & 0x1) as Voltage;\n  }\n\n  override set busVoltage(voltage: number) {\n    // Noop\n  }\n  override get busVoltage(): number {\n    return this.value;\n  }\n}\n\nexport const TRUE_BUS = new ConstantBus(\"true\", 0xffff);\nexport const FALSE_BUS = new ConstantBus(\"false\", 0);\n\nexport function parsePinDecl(toPin: string): {\n  pin: string;\n  width: number;\n} {\n  const { pin, w } = toPin.match(/(?<pin>[a-zA-Z]+)(\\[(?<w>\\d+)\\])?/)\n    ?.groups as {\n    pin: string;\n    w?: string;\n  };\n  return {\n    pin,\n    width: w ? Number(w) : 1,\n  };\n}\n\nexport function parseToPin(toPin: string): {\n  pin: string;\n  start?: number;\n  end?: number;\n} {\n  const { pin, i, j } = toPin.match(\n    /(?<pin>[a-z]+)(\\[(?<i>\\d+)(\\.\\.(?<j>\\d+))?\\])?/\n  )?.groups as { pin: string; i?: string; j?: string };\n  return {\n    pin,\n    start: i ? Number(i) : undefined,\n    end: j ? Number(j) : undefined,\n  };\n}\n\nexport class Pins {\n  private readonly map = new Map<string, Pin>();\n\n  insert(pin: Pin) {\n    const { name } = pin;\n    assert(!this.map.has(name), `Pins already has ${name}!`);\n    this.map.set(name, pin);\n  }\n\n  emplace(name: string, minWidth?: number) {\n    if (this.has(name)) {\n      return this.get(name)!;\n    } else {\n      const pin = new Bus(name, minWidth);\n      this.insert(pin);\n      return pin;\n    }\n  }\n\n  has(pin: string): boolean {\n    return this.map.has(pin);\n  }\n\n  get(pin: string): Pin | undefined {\n    return this.map.get(pin);\n  }\n\n  entries(): Iterable<Pin> {\n    return this.map.values();\n  }\n\n  [Symbol.iterator]() {\n    return this.map[Symbol.iterator]();\n  }\n}\n\nlet id = 0;\nexport class Chip {\n  readonly id = id++;\n  ins = new Pins();\n  outs = new Pins();\n  pins = new Pins();\n  parts = new Set<Chip>();\n  clockedPins: Set<string>;\n\n  get clocked() {\n    if (this.clockedPins.size > 0) {\n      return true;\n    }\n    for (const part of this.parts) {\n      if (part.clocked) return true;\n    }\n    return false;\n  }\n\n  constructor(\n    ins: (string | { pin: string; width: number })[],\n    outs: (string | { pin: string; width: number })[],\n    public name?: string,\n    internals: (string | { pin: string; width: number })[] = [],\n    clocked: string[] = []\n  ) {\n    for (const inn of ins) {\n      const { pin, width = 1 } =\n        (inn as { pin: string }).pin !== undefined\n          ? (inn as { pin: string; width: number })\n          : parsePinDecl(inn as string);\n      this.ins.insert(new Bus(pin, width));\n    }\n\n    for (const out of outs) {\n      const { pin, width = 1 } =\n        (out as { pin: string }).pin !== undefined\n          ? (out as { pin: string; width: number })\n          : parsePinDecl(out as string);\n      this.outs.insert(new Bus(pin, width));\n    }\n\n    for (const internal of internals) {\n      const { pin, width = 1 } =\n        (internal as { pin: string }).pin !== undefined\n          ? (internal as { pin: string; width: number })\n          : parsePinDecl(internal as string);\n      this.pins.insert(new Bus(pin, width));\n    }\n\n    this.clockedPins = new Set(clocked);\n\n    Clock.get().$.subscribe(() => this.eval());\n  }\n\n  reset() {\n    for (const [_, pin] of this.ins) {\n      pin.busVoltage = 0;\n    }\n    for (const part of this.parts) {\n      part.reset();\n    }\n    this.eval();\n  }\n\n  in(pin = \"in\"): Pin {\n    assert(this.hasIn(pin), `No in pin ${pin}`);\n    return this.ins.get(pin)!;\n  }\n\n  out(pin = \"out\"): Pin {\n    assert(this.hasOut(pin), `No in pin ${pin}`);\n    return this.outs.get(pin)!;\n  }\n\n  hasIn(pin: string): boolean {\n    return this.ins.has(pin);\n  }\n\n  hasOut(pin: string): boolean {\n    return this.outs.has(pin);\n  }\n\n  pin(name: string): Pin {\n    assert(this.pins.has(name));\n    return this.pins.get(name)!;\n  }\n\n  get(name: string, offset?: number): Pin | undefined {\n    if (this.ins.has(name)) {\n      return this.ins.get(name)!;\n    }\n    if (this.outs.has(name)) {\n      return this.outs.get(name)!;\n    }\n    if (this.pins.has(name)) {\n      return this.pins.get(name)!;\n    }\n    return this.getBuiltin(name, offset);\n  }\n\n  private getBuiltin(name: string, offset = 0): Pin | undefined {\n    if (BUILTIN_NAMES.includes(name)) {\n      for (const part of this.parts) {\n        const pin = part.get(name, offset);\n        if (pin) {\n          return pin;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  isOutPin(pin: string): boolean {\n    return this.outs.has(pin);\n  }\n\n  wire(part: Chip, connections: Connection[]) {\n    this.parts.add(part);\n    for (const { to, from } of connections) {\n      if (part.isOutPin(to.name)) {\n        this.wireOutPin(part, to, from);\n      } else {\n        this.wireInPin(part, to, from);\n      }\n    }\n  }\n\n  private findPin(from: string, minWidth?: number): Pin {\n    if (from.toLowerCase() === \"true\" || from === \"1\") {\n      return TRUE_BUS;\n    }\n    if (from.toLowerCase() === \"false\" || from === \"0\") {\n      return FALSE_BUS;\n    }\n    if (this.ins.has(from)) {\n      return this.ins.get(from)!;\n    }\n    if (this.outs.has(from)) {\n      return this.outs.get(from)!;\n    }\n    return this.pins.emplace(from, minWidth);\n  }\n\n  private wireOutPin(part: Chip, to: PinSide, from: PinSide) {\n    const partPin = assertExists(\n      part.outs.get(to.name),\n      () => `Cannot wire to missing pin ${to.name}`\n    );\n    to.width ??= partPin.width;\n\n    let chipPin = this.findPin(from.name, from.width ?? to.width);\n    const isInternal = this.pins.has(chipPin.name);\n\n    from.width ??= chipPin.width;\n\n    if (chipPin instanceof ConstantBus) {\n      throw new Error(`Cannot wire to constant bus`);\n    }\n\n    // Widen internal pins\n    if (isInternal && chipPin instanceof Bus) {\n      chipPin.ensureWidth(from.start + from.width);\n    }\n\n    // Wrap the chipPin in an InBus when the chip side is dimensioned\n    if (from.start > 0 || from.width !== chipPin.width) {\n      chipPin = new InSubBus(chipPin, from.start, from.width);\n    }\n\n    // Wrap the chipPin in an OutBus when the part side is dimensioned\n    if (to.start > 0 || to.width !== chipPin.width) {\n      chipPin = new OutSubBus(chipPin, to.start, to.width);\n    }\n\n    partPin.connect(chipPin);\n  }\n\n  private wireInPin(part: Chip, to: PinSide, from: PinSide) {\n    let partPin = assertExists(\n      part.ins.get(to.name),\n      () => `Cannot wire to missing pin ${to.name}`\n    );\n    to.width ??= partPin.width;\n\n    const chipPin = this.findPin(from.name, from.width ?? to.width);\n\n    from.width ??= chipPin.width;\n\n    // Wrap the partPin in an InBus when the part side is dimensioned\n    if (to.start > 0 || to.width !== chipPin.width) {\n      partPin = new InSubBus(partPin, to.start, to.width);\n    }\n\n    // Wrap the partPin in an OutBus when the chip side is dimensioned\n    if (![\"true\", \"false\"].includes(chipPin.name)) {\n      if (from.start > 0 || from.width !== chipPin.width) {\n        partPin = new OutSubBus(partPin, from.start, from.width);\n      }\n    }\n    chipPin.connect(partPin);\n  }\n\n  eval() {\n    for (const chip of this.parts) {\n      // TODO topological sort\n      // eval chip input busses\n      TRUE_BUS.next.forEach((pin) => (pin.busVoltage = TRUE_BUS.busVoltage));\n      FALSE_BUS.next.forEach((pin) => (pin.busVoltage = FALSE_BUS.busVoltage));\n      chip.eval();\n      // eval output busses\n    }\n  }\n\n  tick() {\n    this.eval();\n  }\n\n  tock() {\n    this.eval();\n  }\n\n  remove() {\n    for (const part of this.parts) {\n      part.remove();\n    }\n  }\n\n  // For the ROM32K builtin to load from a file system\n  async load(fs: FileSystem, path: string): Promise<void> {\n    for (const part of this.parts) {\n      if (part.name === \"ROM32K\") {\n        await part.load(fs, path);\n      }\n    }\n  }\n}\n\nexport class Low extends Chip {\n  constructor() {\n    super([], []);\n    this.outs.insert(FALSE_BUS);\n  }\n}\n\nexport class High extends Chip {\n  constructor() {\n    super([], []);\n    this.outs.insert(TRUE_BUS);\n  }\n}\n\nexport class ClockedChip extends Chip {\n  override get clocked(): boolean {\n    return true;\n  }\n\n  #subscription = Clock.get().$.subscribe(({ level }) => {\n    if (level === LOW) {\n      this.tock();\n    } else {\n      this.tick();\n    }\n  });\n\n  override remove() {\n    this.#subscription.unsubscribe();\n    super.remove();\n  }\n\n  override reset(): void {\n    super.reset();\n    this.tick();\n    this.tock();\n  }\n}\n\nexport interface PinSide {\n  name: string;\n  start: number;\n  width?: number;\n}\n\nexport interface Connection {\n  // To is the part side\n  to: PinSide;\n  // From is the chip side\n  from: PinSide;\n}\n\nexport type Pinout = Record<string, string>;\nexport interface SerializedChip {\n  id: number;\n  name: string;\n  ins: Pinout;\n  outs: Pinout;\n  pins: Pinout;\n  children: SerializedChip[];\n}\n\nfunction mask(width: number) {\n  return Math.pow(2, width) - 1;\n}\n\nfunction setBus(busses: Pinout, pin: Pin) {\n  busses[pin.name] = bin(\n    (pin.busVoltage & mask(pin.width)) <<\n      (pin as unknown as { start: number }).start ?? 0\n  );\n  return busses;\n}\n\nexport function printChip(chip: Chip): SerializedChip {\n  return {\n    id: chip.id,\n    name: chip.name ?? chip.constructor.name,\n    ins: [...chip.ins.entries()].reduce(setBus, {} as Pinout),\n    outs: [...chip.outs.entries()].reduce(setBus, {} as Pinout),\n    pins: [...chip.pins.entries()].reduce(setBus, {} as Pinout),\n    children: [...chip.parts.values()].map(printChip),\n  };\n}\n\nexport const BUILTIN_NAMES = [\n  \"Register\",\n  \"ARegister\",\n  \"DRegister\",\n  \"PC\",\n  \"RAM8\",\n  \"RAM64\",\n  \"RAM512\",\n  \"RAM4K\",\n  \"RAM16K\",\n  \"ROM32K\",\n  \"Screen\",\n  \"Keyboard\",\n  \"Memory\",\n];\n","import { BehaviorSubject, Observable, Subject } from \"rxjs\";\nimport { assert } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { HIGH, LOW, Voltage } from \"./chip.js\";\n\ninterface Tick {\n  readonly level: Voltage;\n  readonly ticks: number;\n}\n\nlet clock: Clock;\nexport class Clock {\n  private level: Voltage = LOW;\n  private ticks = 0;\n\n  static get() {\n    if (clock === undefined) {\n      clock = new Clock();\n    }\n    return clock;\n  }\n\n  get isHigh(): boolean {\n    return this.level === HIGH;\n  }\n\n  get isLow(): boolean {\n    return this.level === LOW;\n  }\n\n  private subject = new BehaviorSubject<Tick>({\n    level: this.level,\n    ticks: this.ticks,\n  });\n  readonly frameSubject = new Subject<void>();\n  readonly resetSubject = new Subject<void>();\n\n  readonly $: Observable<Tick> = this.subject;\n  readonly frame$: Observable<void> = this.frameSubject;\n  readonly reset$: Observable<void> = this.resetSubject;\n\n  private next() {\n    this.subject.next({\n      level: this.level,\n      ticks: this.ticks,\n    });\n  }\n\n  private constructor() {\n    // private\n  }\n\n  reset() {\n    this.level = LOW;\n    this.ticks = 0;\n    this.next();\n    this.resetSubject.next();\n  }\n\n  tick() {\n    assert(this.level === LOW, \"Can only tick up from LOW\");\n    this.level = HIGH;\n    this.next();\n  }\n\n  tock() {\n    assert(this.level === HIGH, \"Can only tock down from HIGH\");\n    this.level = LOW;\n    this.ticks += 1;\n    this.next();\n  }\n\n  toggle() {\n    this.level === HIGH ? this.tock() : this.tick();\n  }\n\n  eval() {\n    this.tick();\n    this.tock();\n  }\n\n  frame() {\n    this.frameSubject.next();\n  }\n\n  toString() {\n    return `${this.ticks}${this.level === HIGH ? \"+\" : \"\"}`;\n  }\n}\n","export type COMMANDS_ASM =\n  | \"0\"\n  | \"1\"\n  | \"-1\"\n  | \"D\"\n  | \"A\"\n  | \"M\"\n  | \"!D\"\n  | \"!A\"\n  | \"-D\"\n  | \"-A\"\n  | \"D+1\"\n  | \"A+1\"\n  | \"D-1\"\n  | \"A-1\"\n  | \"D+A\"\n  | \"D-A\"\n  | \"D-M\"\n  | \"A-D\"\n  | \"D&A\"\n  | \"D&M\"\n  | \"D|A\"\n  | \"D|M\";\n\nexport type COMMANDS_OP =\n  | 0b101010\n  | 0b111111\n  | 0b111010\n  | 0b001100\n  | 0b110000\n  | 0b110000\n  | 0b001101\n  | 0b110001\n  | 0b001111\n  | 0b110011\n  | 0b011111\n  | 0b110111\n  | 0b001110\n  | 0b110010\n  | 0b000010\n  | 0b010011\n  | 0b010011\n  | 0b000111\n  | 0b000000\n  | 0b000000\n  | 0b010101\n  | 0b010101;\n\n//Usefull for the visualization of the ALU\nexport type COMMANDS_ALU =\n  | \"0\"\n  | \"1\"\n  | \"-1\"\n  | \"x\"\n  | \"y\"\n  | \"!x\"\n  | \"!y\"\n  | \"-x\"\n  | \"-y\"\n  | \"x+1\"\n  | \"y+1\"\n  | \"x-1\"\n  | \"y-1\"\n  | \"x+y\"\n  | \"x-y\"\n  | \"y-x\"\n  | \"x&y\"\n  | \"x|y\";\n\nexport const COMMANDS_ALU: {\n  op: Record<COMMANDS_OP, COMMANDS_ALU>;\n} = {\n  op: {\n    0x2a: \"0\",\n    0x3f: \"1\",\n    0x3a: \"-1\",\n    0x0c: \"x\",\n    0x30: \"y\",\n    0x0d: \"!x\",\n    0x31: \"!y\",\n    0x0f: \"-x\",\n    0x33: \"-y\",\n    0x1f: \"x+1\",\n    0x37: \"y+1\",\n    0x0e: \"x-1\",\n    0x32: \"y-1\",\n    0x02: \"x+y\",\n    0x13: \"x-y\",\n    0x07: \"y-x\",\n    0x00: \"x&y\",\n    0x15: \"x|y\",\n  },\n};\n\nexport const COMMANDS: {\n  asm: Record<COMMANDS_ASM, COMMANDS_OP>;\n  op: Record<COMMANDS_OP, COMMANDS_ASM>;\n} = {\n  asm: {\n    \"0\": 0b101010, // 42 0x2A\n    \"1\": 0b111111, // 63 0x3F\n    \"-1\": 0b111010, // 58 0x3A\n    D: 0b001100, // 12 0x0C\n    A: 0b110000, // 48 0x30\n    M: 0b110000, // 48 0x30\n    \"!D\": 0b001101, // 13 0x0D\n    \"!A\": 0b110001, // 49 0x31\n    \"-D\": 0b001111, // 15 0x0F\n    \"-A\": 0b110011, // 51 0x33\n    \"D+1\": 0b011111, // 31 0x1F\n    \"A+1\": 0b110111, // 55 0x37\n    \"D-1\": 0b001110, // 14 0x0E\n    \"A-1\": 0b110010, // 50 0x32\n    \"D+A\": 0b000010, //  2 0x02\n    \"D-A\": 0b010011, // 19 0x13\n    \"D-M\": 0b010011, // 19 0x13\n    \"A-D\": 0b000111, //  7 0x07\n    \"D&A\": 0b000000, //  0 0x00\n    \"D&M\": 0b000000, //  0 0x00\n    \"D|A\": 0b010101, // 21 0x15\n    \"D|M\": 0b010101, // 21 0x15\n  },\n  op: {\n    0x2a: \"0\",\n    0x3f: \"1\",\n    0x3a: \"-1\",\n    0x0c: \"D\",\n    0x30: \"A\",\n    0x0d: \"!D\",\n    0x31: \"!A\",\n    0x0f: \"-D\",\n    0x33: \"-A\",\n    0x1f: \"D+1\",\n    0x37: \"A+1\",\n    0x0e: \"D-1\",\n    0x32: \"A-1\",\n    0x02: \"D+A\",\n    0x13: \"D-A\",\n    0x07: \"A-D\",\n    0x00: \"D&A\",\n    0x15: \"D|A\",\n  },\n};\n\nexport type ASSIGN_ASM = \"\" | \"M\" | \"D\" | \"MD\" | \"A\" | \"AM\" | \"AD\" | \"AMD\";\nexport type ASSIGN_OP = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\n\nexport const ASSIGN: {\n  asm: Record<ASSIGN_ASM, ASSIGN_OP>;\n  op: Record<ASSIGN_OP, ASSIGN_ASM>;\n} = {\n  asm: {\n    \"\": 0x0,\n    M: 0b001,\n    D: 0b010,\n    MD: 0b011,\n    A: 0b100,\n    AM: 0b101,\n    AD: 0b110,\n    AMD: 0b111,\n  },\n  op: {\n    0x0: \"\",\n    0x1: \"M\",\n    0x2: \"D\",\n    0x3: \"MD\",\n    0x4: \"A\",\n    0x5: \"AM\",\n    0x6: \"AD\",\n    0x7: \"AMD\",\n  },\n};\n\nexport type JUMP_ASM =\n  | \"\"\n  | \"JGT\"\n  | \"JEQ\"\n  | \"JGE\"\n  | \"JLT\"\n  | \"JNE\"\n  | \"JLE\"\n  | \"JMP\";\nexport type JUMP_OP = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\nexport const JUMP: {\n  asm: Record<JUMP_ASM, JUMP_OP>;\n  op: Record<JUMP_OP, JUMP_ASM>;\n} = {\n  asm: {\n    \"\": 0b0,\n    JGT: 0b001,\n    JEQ: 0b010,\n    JGE: 0b011,\n    JLT: 0b100,\n    JNE: 0b101,\n    JLE: 0b110,\n    JMP: 0b111,\n  },\n  op: {\n    0x0: \"\",\n    0x1: \"JGT\",\n    0x2: \"JEQ\",\n    0x3: \"JGE\",\n    0x4: \"JLT\",\n    0x5: \"JNE\",\n    0x6: \"JLE\",\n    0x7: \"JMP\",\n  },\n};\n\nexport const Flags = {\n  0x01: \"Positive\",\n  0x00: \"Zero\",\n  0x0f: \"Negative\",\n  Positive: 0x01,\n  Zero: 0x00,\n  Negative: 0x0f,\n};\n\nexport function alu(op: number, d: number, a: number): [number, number] {\n  let o = 0;\n  switch (op) {\n    case 0x2a:\n      o = 0;\n      break;\n    case 0x3f:\n      o = 1;\n      break;\n    case 0x3a:\n      o = -1;\n      break;\n    case 0x0c:\n      o = d;\n      break;\n    case 0x30:\n      o = a;\n      break;\n    case 0x0d:\n      o = ~d;\n      break;\n    case 0x31:\n      o = ~a;\n      break;\n    case 0x0f:\n      o = -d;\n      break;\n    case 0x33:\n      o = -a;\n      break;\n    case 0x1f:\n      o = d + 1;\n      break;\n    case 0x37:\n      o = a + 1;\n      break;\n    case 0x0e:\n      o = d - 1;\n      break;\n    case 0x32:\n      o = a - 1;\n      break;\n    case 0x02:\n      o = d + a;\n      break;\n    case 0x13:\n      o = d - a;\n      break;\n    case 0x07:\n      o = a - d;\n      break;\n    case 0x00:\n      o = d & a;\n      break;\n    case 0x15:\n      o = d | a;\n      break;\n  }\n\n  o = o & 0xffff;\n  const flags =\n    o === 0 ? Flags.Zero : o & 0x8000 ? Flags.Negative : Flags.Positive;\n  return [o, flags];\n}\n\nexport function alua(op: number, d: number, a: number): [number, number] {\n  if (op & 0b100000) d = 0;\n  if (op & 0b010000) d = ~d & 0xffff;\n  if (op & 0b001000) a = 0;\n  if (op & 0b000100) a = ~a & 0xffff;\n\n  let o = (op & 0b000010 ? d + a : d & a) & 0xffff;\n  if (op & 0b000001) o = ~o & 0xffff;\n\n  const flags =\n    o === 0 ? Flags.Zero : o & 0x8000 ? Flags.Negative : Flags.Positive;\n  return [o, flags];\n}\n","import { alu, COMMANDS_OP, Flags } from \"./alu.js\";\nimport {\n  Memory,\n  MemoryAdapter,\n  MemoryKeyboard,\n  SubMemory,\n  RAM as RAMMem,\n  SCREEN_OFFSET,\n  SCREEN_SIZE,\n} from \"./memory.js\";\n\nexport interface CPUInput {\n  inM: number;\n  instruction: number;\n  reset: boolean;\n}\n\nexport interface CPUOutput {\n  outM: number;\n  writeM: boolean;\n  addressM: number;\n}\n\nexport interface CPUState {\n  A: number;\n  D: number;\n  PC: number;\n  ALU: number;\n  flag: number;\n}\n\nexport function emptyState(): CPUState {\n  return { A: 0, D: 0, PC: 0, ALU: 0, flag: Flags.Zero };\n}\n\nconst BITS = {\n  c: 0b1000_0000_0000_0000,\n  x1: 0b1001_0000_0000_0000,\n  x2: 0b1001_0000_0000_0000,\n  am: 0b1001_0000_0000_0000,\n  op: 0b0000_1111_1100_0000,\n  d1: 0b1000_0000_0010_0000,\n  d2: 0b1000_0000_0001_0000,\n  d3: 0b1000_0000_0000_1000,\n  j1: 0b1000_0000_0000_0001,\n  j2: 0b1000_0000_0000_0010,\n  j3: 0b1000_0000_0000_0100,\n};\n\nexport function decode(instruction: number) {\n  function bit(bit: number): boolean {\n    return (instruction & bit) === bit;\n  }\n  const bits = {\n    c: bit(BITS.c),\n    x1: bit(BITS.x1),\n    x2: bit(BITS.x2),\n    am: bit(BITS.am),\n    op: ((instruction & BITS.op) >> 6) as COMMANDS_OP,\n    d1: bit(BITS.d1),\n    d2: bit(BITS.d2),\n    d3: bit(BITS.d3),\n    j1: bit(BITS.j1),\n    j2: bit(BITS.j2),\n    j3: bit(BITS.j3),\n  };\n\n  return bits;\n}\n\nexport function cpuTick(\n  { inM, instruction }: CPUInput,\n  { A, D, PC }: CPUState\n): [CPUState, boolean] {\n  const bits = decode(instruction);\n  const a = bits.am ? inM : A;\n  const [ALU, flag] = alu(bits.op, D, a);\n\n  return [{ A, D, PC: PC + 1, ALU, flag }, bits.d3];\n}\n\nexport function cpuTock(\n  { inM, instruction, reset }: CPUInput,\n  { A, D, PC, ALU, flag }: CPUState\n): [CPUOutput, CPUState] {\n  const bits = decode(instruction);\n\n  const j1 = bits.j1 && flag === Flags.Positive;\n  const j2 = bits.j2 && flag === Flags.Zero;\n  const j3 = bits.j3 && flag === Flags.Negative;\n  const jmp = j1 || j2 || j3;\n\n  PC = reset ? 0 : jmp ? A : PC;\n\n  if (bits.d2) {\n    D = ALU;\n  }\n\n  const oldA = A;\n  if (!bits.c) {\n    A = instruction & 0x7fff;\n  } else if (bits.d1) {\n    A = ALU;\n  }\n\n  const a = bits.am ? inM : A;\n  const alu2 = alu(bits.op, D, a);\n\n  ALU = alu2[0];\n  flag = alu2[1];\n\n  const output: CPUOutput = {\n    addressM: bits.d3 ? oldA : A,\n    outM: ALU,\n    writeM: bits.d3,\n  };\n\n  const state: CPUState = {\n    A,\n    D,\n    ALU,\n    flag,\n    PC,\n  };\n\n  return [output, state];\n}\n\nexport function cpu(input: CPUInput, state: CPUState): [CPUOutput, CPUState] {\n  const [tickState, _writeM] = cpuTick(input, state);\n  return cpuTock(input, tickState);\n}\n\nexport class CPU {\n  readonly RAM: Memory;\n  readonly ROM: Memory;\n  readonly Screen: MemoryAdapter;\n  readonly Keyboard: MemoryKeyboard;\n\n  #pc = 0;\n  #a = 0;\n  #d = 0;\n\n  #tickState: CPUState = {\n    A: 0,\n    D: 0,\n    PC: 0,\n    ALU: 0,\n    flag: Flags.Zero,\n  };\n\n  get state(): CPUState {\n    return this.#tickState;\n  }\n\n  get PC() {\n    return this.#pc;\n  }\n\n  get A() {\n    return this.#a;\n  }\n\n  get D() {\n    return this.#d;\n  }\n\n  setA(value: number) {\n    this.#a = value;\n  }\n\n  setD(value: number) {\n    this.#d = value;\n  }\n\n  setPC(value: number) {\n    this.#pc = value;\n  }\n\n  constructor({ RAM = new RAMMem(), ROM }: { RAM?: Memory; ROM: Memory }) {\n    this.RAM = RAM;\n    this.ROM = ROM;\n\n    // \"Device Map\"\n    this.Screen = new SubMemory(this.RAM, SCREEN_SIZE, SCREEN_OFFSET);\n    this.Keyboard = new MemoryKeyboard(this.RAM);\n  }\n\n  reset() {\n    this.#pc = 0;\n    this.#a = 0;\n    this.#d = 0;\n  }\n\n  tick() {\n    const [{ addressM, outM, writeM }, { A, D, PC }] = cpu(\n      {\n        inM: this.RAM.get(this.#a),\n        instruction: this.ROM.get(this.#pc),\n        reset: false,\n      },\n      {\n        A: this.#a,\n        D: this.#d,\n        PC: this.#pc,\n        ALU: this.#d,\n        flag: Flags.Zero,\n      }\n    );\n\n    this.#a = A;\n    this.#d = D;\n    this.#pc = PC;\n\n    if (writeM) {\n      this.RAM.set(addressM, outM);\n    }\n  }\n}\n","import { assert } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport { op } from \"../util/asm.js\";\nimport { int10, int16, int2 } from \"../util/twos.js\";\nimport { load } from \"../fs.js\";\n\nexport const FORMATS = [\"bin\", \"dec\", \"hex\", \"asm\"];\nexport type Format = typeof FORMATS[number];\n\nexport const SCREEN_OFFSET = 0x4000;\nexport const SCREEN_ROWS = 512;\nexport const SCREEN_COLS = 256;\nexport const SCREEN_SIZE = SCREEN_ROWS * SCREEN_COLS;\nexport const KEYBOARD_OFFSET = 0x6000;\n\nexport interface MemoryAdapter {\n  size: number;\n  get(index: number): number;\n  set(index: number, value: number): void;\n  reset(): void;\n  update(cell: number, value: string, format: Format): void;\n  load(fs: FileSystem, path: string): Promise<void>;\n  loadBytes(bytes: number[]): void;\n  range(start?: number, end?: number): number[];\n  map<T>(\n    fn: (index: number, value: number) => T,\n    start?: number,\n    end?: number\n  ): Iterable<T>;\n}\n\nexport interface KeyboardAdapter {\n  getKey(): number;\n  setKey(key: number): void;\n  clearKey(): void;\n}\n\nexport class Memory implements MemoryAdapter {\n  private memory: Int16Array;\n\n  get size(): number {\n    return this.memory.length;\n  }\n\n  constructor(memory: ArrayBuffer | number) {\n    if (typeof memory === \"number\") {\n      this.memory = new Int16Array(memory);\n    } else {\n      this.memory = new Int16Array(memory);\n    }\n  }\n\n  get(index: number): number {\n    if (index < 0 || index >= this.size) {\n      return 0xffff;\n    }\n    return this.memory[index] ?? 0;\n  }\n\n  set(index: number, value: number): void {\n    if (index >= 0 && index < this.size) {\n      this.memory[index] = value & 0xffff;\n    }\n  }\n\n  reset(): void {\n    this.memory.fill(0);\n  }\n\n  update(cell: number, value: string, format: Format) {\n    let current: number;\n    switch (format) {\n      case \"asm\":\n        current = op(value);\n        break;\n      case \"bin\":\n        current = int2(value);\n        break;\n      case \"hex\":\n        current = int16(value);\n        break;\n      case \"dec\":\n      default:\n        current = int10(value);\n        break;\n    }\n\n    if (isFinite(current) && current <= 0xffff) {\n      this.set(cell, current);\n    }\n  }\n\n  async load(fs: FileSystem, path: string) {\n    try {\n      this.loadBytes(await load(fs, path));\n    } catch (cause) {\n      // throw new Error(`ROM32K Failed to load file ${path}`, { cause });\n      throw new Error(`Memory Failed to load file ${path}`);\n    }\n  }\n\n  loadBytes(bytes: number[]): void {\n    this.memory.set(new Int16Array(bytes));\n    this.memory.fill(0, bytes.length, this.size);\n  }\n\n  range(start = 0, end = this.size): number[] {\n    return [...this.memory.slice(start, end)];\n  }\n\n  *map<T>(\n    fn: (index: number, value: number) => T,\n    start = 0,\n    end = this.size\n  ): Iterable<T> {\n    assert(start < end);\n    for (let i = start; i < end; i++) {\n      yield fn(i, this.get(i));\n    }\n  }\n}\n\nexport class SubMemory implements MemoryAdapter {\n  constructor(\n    private readonly parent: MemoryAdapter,\n    readonly size: number,\n    private readonly offset: number\n  ) {}\n\n  get(index: number): number {\n    if (index < 0 || index >= this.size) {\n      return 0xffff;\n    }\n    return this.parent.get(this.offset + index);\n  }\n\n  set(index: number, value: number): void {\n    if (index >= 0 && index < this.size) {\n      this.parent.set(index + this.offset, value);\n    }\n  }\n\n  reset(): void {\n    for (let i = 0; i < this.size; i++) {\n      this.set(i, 0);\n    }\n  }\n\n  update(index: number, value: string, format: string): void {\n    if (index >= 0 && index < this.size) {\n      this.parent.update(index + this.offset, value, format);\n    }\n  }\n\n  load(fs: FileSystem, path: string): Promise<void> {\n    return this.parent.load(fs, path);\n  }\n\n  loadBytes(bytes: number[]): void {\n    return this.parent.loadBytes(bytes);\n  }\n\n  range(start?: number, end?: number): number[] {\n    return this.parent.range(start, end);\n  }\n  map<T>(\n    fn: (index: number, value: number) => T,\n    start?: number,\n    end?: number\n  ): Iterable<T> {\n    return this.parent.map(fn, start, end);\n  }\n}\n\nexport class MemoryKeyboard extends SubMemory implements KeyboardAdapter {\n  constructor(memory: MemoryAdapter) {\n    super(memory, 1, 0x6000);\n  }\n\n  getKey(): number {\n    return this.get(0);\n  }\n\n  setKey(key: number): void {\n    this.set(0, key & 0xffff);\n  }\n\n  clearKey(): void {\n    this.set(0, 0);\n  }\n}\n\nexport class ROM extends Memory {\n  static readonly SIZE = 0x8000;\n  constructor(program: Int16Array) {\n    const arr = new Int16Array(ROM.SIZE);\n    arr.set(program);\n    super(arr);\n  }\n}\n\nexport class RAM extends Memory {\n  // 4k main memory, 2k screen memory, 1 keyboard\n  // static readonly SIZE = 0x4000 + 0x2000 + 0x0001;\n  static readonly SIZE = 0x8000;\n  constructor() {\n    super(RAM.SIZE);\n  }\n}\n","import { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport * as loader from \"./loader.js\";\n\nexport async function load(fs: FileSystem, path: string): Promise<number[]> {\n  if (path.endsWith(\".hack\")) {\n    return loadHack(fs, path);\n  }\n\n  if (path.endsWith(\".asm\")) {\n    return loadAsm(fs, path);\n  }\n\n  throw new Error(`Cannot load file without hack or asm extension ${path}`);\n}\n\nexport async function loadAsm(fs: FileSystem, path: string): Promise<number[]> {\n  return loader.loadAsm(await fs.readFile(path));\n}\n\nexport async function loadHack(\n  fs: FileSystem,\n  path: string\n): Promise<number[]> {\n  return loader.loadHack(await fs.readFile(path));\n}\n","const base = `\nBase {\n  Root = Value*\n\n  At = at\n  Bang = bang\n  Bar = bar\n  CloseAngle = closeAngle\n  CloseBrace = closeBrace\n  CloseParen = closeParen\n  CloseSquare = closeSquare\n  Comma = comma\n  Dollar = dollar\n  Dot = dot\n  DoubleQuote = doubleQuote\n  Equal = equal\n  OpenAngle = openAngle\n  OpenBrace = openBrace\n  OpenParen = openParen\n  OpenSquare = openSquare\n  Percent = percent\n  Semi = semi\n  Underscore = underscore\n\n  at = \"@\"\n  bang = \"!\"\n  bar = \"|\"\n  closeAngle = \">\"\n  closeBrace = \"}\"\n  closeParen = \")\"\n  closeSquare = \"]\"\n  comma = \",\"\n  dollar = \"$\"\n  dot = \".\"\n  doubleQuote = \"\\\\\"\"\n  equal = \"=\"\n  minus = \"-\"\n  newline = \"\\\\r\"? \"\\\\n\"\n  openAngle = \"<\"\n  openBrace = \"{\"\n  openParen = \"(\"\n  openSquare = \"[\"\n  percent = \"%\"\n  semi = \";\"\n  underscore = \"_\"\n\n  Value = identifier | number | boolean\n\n  boolean = true | false\n  True = true\n  False = false\n  true = \"true\"\n  false = \"false\"\n\n  Name = identifier\n  identifier = (letter|underscore) (alnum|underscore|dot|dollar)*\n\n  Number = number\n  number = hexNumber | decNumber | binNumber\n  binNumber = (\"%B\") (\"0\"|\"1\")+\n  hexNumber = (\"%X\") hexDigit+\n  decNumber = (\"%D\")? (wholeDec | realDec)\n  wholeDec = minus? digit+\n  realDec = minus? digit* \".\" digit+\n\n  String = DoubleQuote (~doubleQuote any)* doubleQuote\n  \n  spaces := (lineComment | comment | space)*\n  commentStart = \"/*\"\n  commentEnd = \"*/\"\n  comment = commentStart (~commentEnd any)* commentEnd\n  lineCommentStart = \"//\"\n  lineComment = lineCommentStart (~\"\\\\n\" any)* \"\\\\n\"\n\n  List<elem, sep> = NonemptyListOf<elem, sep> sep?\n  EmptyList<elem, sep> = EmptyList<elem, sep> sep?\n}`;\nexport default base;\n","import ohm from \"ohm-js\";\nimport { int10, int16, int2 } from \"../util/twos.js\";\nimport { Err, Ok, Result } from \"@davidsouther/jiffies/lib/esm/result.js\";\n\nexport const UNKNOWN_PARSE_ERROR = `Unknown parse error`;\n\nimport baseGrammar from \"./grammars/base.ohm.js\";\nexport const grammars = {\n  Base: ohm.grammar(baseGrammar),\n};\n\nexport const baseSemantics = grammars.Base.createSemantics();\n\nbaseSemantics.extendOperation(\"asIteration\", {\n  List(list, _) {\n    return list.asIteration();\n  },\n});\n\nbaseSemantics.addAttribute(\"value\", {\n  decNumber(_, digits): number {\n    return int10(digits.sourceString);\n  },\n  wholeDec(_, digits): number {\n    return int10(digits.sourceString);\n  },\n  binNumber(_, digits) {\n    return int2(digits.sourceString);\n  },\n  hexNumber(_, digits) {\n    return int16(digits.sourceString);\n  },\n  Number(num) {\n    return num.value;\n  },\n  Name(ident) {\n    return ident.name;\n  },\n  identifier(_, __): string {\n    return this.sourceString;\n  },\n});\n\nbaseSemantics.addAttribute(\"name\", {\n  identifier(_, __): string {\n    return this.sourceString;\n  },\n  Name(_): string {\n    return this.child(0)?.name;\n  },\n});\n\nbaseSemantics.addAttribute(\"String\", {\n  String(_a, str, _b) {\n    return str.sourceString;\n  },\n});\n\nexport type ParseError = Error | { message: string; shortMessage: string };\n\nexport function makeParser<ResultType>(\n  grammar: ohm.Grammar,\n  semantics: ohm.Semantics,\n  property: (obj: ohm.Dict) => ResultType = ({ root }) => root\n): (source: string) => Result<ResultType, ParseError> {\n  return function parse(source) {\n    try {\n      const match = grammar.match(source);\n      if (match.succeeded()) {\n        const parsed = semantics(match);\n        const parse = property(parsed);\n        return Ok(parse);\n      } else {\n        return Err({\n          message: match.message ?? UNKNOWN_PARSE_ERROR,\n          shortMessage: match.shortMessage ?? UNKNOWN_PARSE_ERROR,\n        });\n      }\n    } catch (e) {\n      return Err(e as Error);\n    }\n  };\n}\n\nexport interface Span {\n  start: number;\n  end: number;\n}\n","const cmp = `\nCmp <: Base {\n  Root := line*\n  line = bar cell+ newline?\n  cell = cellvalue bar\n  cellvalue = (~(bar|newline) any)*\n}`;\nexport default cmp;\n","import ohm from \"ohm-js\";\nimport { grammars, makeParser, baseSemantics } from \"./base.js\";\n\nexport type Cell = string;\nexport type Line = Cell[];\nexport type Cmp = Line[];\n\nimport cmpGrammar from \"./grammars/cmp.ohm.js\";\nexport const grammar = ohm.grammar(cmpGrammar, grammars);\nexport const cmpSemantics = grammar.extendSemantics(baseSemantics);\n\ncmpSemantics.addAttribute<Cell>(\"cell\", {\n  cell(value, _) {\n    return value.sourceString;\n  },\n});\n\ncmpSemantics.addAttribute<Line>(\"line\", {\n  line(_a, cells, _b) {\n    return cells.children.map((c) => c.cell);\n  },\n});\n\ncmpSemantics.addAttribute<Cmp>(\"root\", {\n  Root(lines) {\n    return lines.children.map((c) => c.line);\n  },\n});\n\nexport const CMP = {\n  grammar: cmpGrammar,\n  semantics: cmpSemantics,\n  parser: grammar,\n  parse: makeParser<Cmp>(grammar, cmpSemantics),\n};\n","const tst = `\nTst <: Base {\n  Root := Tst\n  Tst = (TstStatement | TstRepeat | TstWhile)+\n\n  TstRepeat = Repeat Number? OpenBrace TstStatement+ CloseBrace\n  TstWhile = While Condition OpenBrace TstStatement+ CloseBrace\n  TstStatement = List<TstOperation, \",\"> (Semi | Bang)\n\n  TstOperation =\n    | TstFileOperation\n    | TstOutputListOperation\n    | TstEvalOperation\n    | TstSetOperation\n    | TstOutputOperation\n    | TstEchoOperation\n    | TstClearEchoOperation\n    | TstLoadROMOperation\n\n  TstLoadROMOperation = ROM32K Load FileName\n  TstFileOperation = FileOperation FileName\n  TstOutputListOperation = \"output-list\" OutputFormat+\n  OutputFormat = Name Index? percent FormatStyle wholeDec dot wholeDec dot wholeDec\n  TstSetOperation = Set Name Index? Number\n  Index = OpenSquare wholeDec? CloseSquare\n  Condition = Value CompareOp Value\n  TstEvalOperation = Eval | Tick | Tock | TickTock\n  TstOutputOperation = Output\n  TstEchoOperation = Echo String\n  TstClearEchoOperation = ClearEcho\n\n  FileName = Name\n  FileOperation = \"load\" | \"output-file\" | \"compare-to\"\n\n  Set = \"set\"\n  Eval = \"eval\"\n  Tick = \"tick\"\n  Tock = \"tock\"\n  TickTock = \"ticktock\"\n  Echo = \"echo\"\n  Repeat = \"repeat\"\n  ClearEcho = \"clear-echo\"\n  Output = \"output\"\n  OutputList = \"output-list\"\n  FormatStyle = \"B\"|\"D\"|\"S\"|\"X\"\n  ROM32K = \"ROM32K\"\n  Load = \"load\"\n  While = \"while\"\n\n  CompareOp = \"<>\" | \"<=\" | \">=\" | \"=\" | \"<\" | \">\"\n}`;\nexport default tst;\n","/** Reads tst files to apply and perform test runs. */\n\nimport ohm from \"ohm-js\";\nimport { baseSemantics, grammars, makeParser, Span } from \"./base.js\";\n\nexport interface TstEchoOperation {\n  op: \"echo\";\n  message: string;\n}\n\nexport interface TstClearEchoOperation {\n  op: \"clear-echo\";\n}\n\nexport interface TstSetOperation {\n  op: \"set\";\n  id: string;\n  index?: number;\n  value: number;\n}\n\nexport interface TstEvalOperation {\n  op: \"eval\" | \"tick\" | \"tock\";\n}\n\nexport interface TstOutputOperation {\n  op: \"output\";\n}\n\nexport interface TstOutputSpec {\n  id: string;\n  builtin: boolean;\n  address: number;\n  style: \"D\" | \"X\" | \"B\" | \"S\";\n  width: number;\n  lpad: number;\n  rpad: number;\n}\n\nexport interface TstOutputListOperation {\n  op: \"output-list\";\n  spec: TstOutputSpec[];\n}\n\nexport interface TstLoadROMOperation {\n  op: \"loadRom\";\n  file: string;\n}\n\nexport interface TstFileOperation {\n  op: \"load\" | \"output-file\" | \"compare-to\";\n  file: string;\n}\n\nexport type TstOperation =\n  | TstFileOperation\n  | TstEvalOperation\n  | TstEchoOperation\n  | TstClearEchoOperation\n  | TstOutputOperation\n  | TstSetOperation\n  | TstOutputListOperation\n  | TstLoadROMOperation;\n\nexport interface TstLineStatement {\n  ops: TstOperation[];\n  break?: true;\n  span: Span;\n}\n\nexport interface TstRepeat {\n  statements: TstLineStatement[];\n  count: number;\n  span: Span;\n}\n\nexport interface TstWhileCondition {\n  op: \"<\" | \"<=\" | \"=\" | \">=\" | \">\" | \"<>\";\n  left: string | number;\n  right: string | number;\n}\n\nexport interface TstWhileStatement {\n  statements: TstLineStatement[];\n  condition: TstWhileCondition;\n  span: Span;\n}\n\nexport type TstStatement = TstLineStatement | TstRepeat | TstWhileStatement;\n\nexport interface Tst {\n  lines: TstStatement[];\n}\n\nimport tstGrammar from \"./grammars/tst.ohm.js\";\nexport const grammar = ohm.grammar(tstGrammar, grammars);\nexport const tstSemantics = grammar.extendSemantics(baseSemantics);\n\ntstSemantics.extendAttribute<number>(\"value\", {\n  Index(_a, idx, _b) {\n    return idx?.child(0)?.value ?? -1;\n  },\n});\n\ntstSemantics.extendAttribute<string>(\"name\", {\n  FileName({ name }) {\n    return name;\n  },\n});\n\ntstSemantics.addAttribute<number>(\"index\", {\n  Index(_open, dec, _close) {\n    return dec.child(0)?.value ?? 0;\n  },\n});\n\ntstSemantics.addAttribute<TstOutputSpec>(\"format\", {\n  OutputFormat(\n    { name: id },\n    index,\n    _a,\n    { sourceString: style },\n    { value: lpad },\n    _b,\n    { value: width },\n    _c,\n    { value: rpad }\n  ) {\n    return {\n      id,\n      builtin: index?.child(0) !== undefined,\n      address: index?.child(0)?.value ?? -1,\n      style: style as TstOutputSpec[\"style\"],\n      width,\n      lpad,\n      rpad,\n    };\n  },\n});\n\ntstSemantics.addAttribute<TstOperation>(\"operation\", {\n  TstEvalOperation(op) {\n    return { op: op.sourceString as TstEvalOperation[\"op\"] };\n  },\n  TstOutputOperation(_) {\n    return { op: \"output\" };\n  },\n  TstOutputListOperation(_, formats) {\n    return {\n      op: \"output-list\",\n      spec: formats.children.map((n) => n.format),\n    };\n  },\n  TstSetOperation(op, { name }, index, { value }) {\n    const setOp: TstSetOperation = {\n      op: \"set\",\n      id: name,\n      value,\n    };\n    const child = index.child(0)?.child(1)?.child(0);\n    if (child) {\n      setOp.index = child.value;\n    }\n    return setOp;\n  },\n  TstEchoOperation(op, str) {\n    return {\n      op: \"echo\",\n      message: str.String as string,\n    };\n  },\n  TstClearEchoOperation(op) {\n    return {\n      op: \"clear-echo\",\n    };\n  },\n  TstLoadROMOperation(_r, _l, { name }) {\n    return {\n      op: \"loadRom\",\n      file: name,\n    };\n  },\n  TstFileOperation(op, file) {\n    return {\n      op: op.sourceString as TstFileOperation[\"op\"],\n      file: file.sourceString,\n    };\n  },\n});\n\ntstSemantics.addAttribute<TstWhileCondition>(\"condition\", {\n  Condition({ value: left }, { sourceString: op }, { value: right }) {\n    return {\n      left,\n      right,\n      op: op as \"<\" | \"<=\" | \"=\" | \">=\" | \">\" | \"<>\",\n    };\n  },\n});\n\ntstSemantics.addAttribute<TstStatement>(\"statement\", {\n  TstWhile(op, cond, _o, statements, _c) {\n    return {\n      statements: statements.children.map(({ statement }) => statement),\n      condition: cond.condition,\n      span: {\n        start: op.source.startIdx,\n        end: cond.source.endIdx,\n      },\n    };\n  },\n  TstRepeat(op, count, _o, statements, _c) {\n    return {\n      statements: statements.children.map(({ statement }) => statement),\n      count: count.child(0)?.value ?? -1,\n      span: {\n        start: op.source.startIdx,\n        end: count.source.endIdx,\n      },\n    };\n  },\n  TstStatement(list, end) {\n    const stmt: TstStatement = {\n      ops: list\n        .asIteration()\n        .children.map((node) => node.operation as TstOperation),\n      span: {\n        start: this.source.startIdx,\n        end: this.source.endIdx,\n      },\n    };\n    if (end.sourceString === \"!\") {\n      stmt.break = true;\n    }\n    return stmt;\n  },\n});\n\ntstSemantics.addAttribute<Tst>(\"tst\", {\n  Tst(lines) {\n    return {\n      lines: lines.children.map((n) => n.statement),\n    };\n  },\n});\n\ntstSemantics.addAttribute<Tst>(\"root\", {\n  Root({ tst }) {\n    return tst;\n  },\n});\n\nexport const TST = {\n  grammar: tstGrammar,\n  semantics: tstSemantics,\n  parser: grammar,\n  parse: makeParser<Tst>(grammar, tstSemantics),\n};\n","const asm = `\nASM <: Base {\n  Root := ASM\n  ASM = Instruction*\n  \n  Instruction = Label|AInstruction|CInstruction\n  \n  Label = OpenParen identifier closeParen\n  AInstruction = at (identifier | decNumber)\n  CInstruction = assign? op jmp?\n  \n  assign = (\n      \"AMD\"\n      | \"AM\"\n      | \"AD\"\n      | \"MD\"\n      | \"M\"\n      | \"D\"\n      | \"A\"\n      ) equal\n      \n  op =\n      | \"0\" | \"1\" | \"-1\"\n      | \"!D\" | \"!A\" | \"!M\"\n      | \"-D\" | \"-A\" | \"-M\"\n      | \"D+1\" | \"A+1\" | \"M+1\"\n      | \"D-1\" | \"A-1\" | \"M-1\"\n      | \"D+A\" | \"D+M\"\n      | \"D-A\" | \"D-M\"\n      | \"A-D\" | \"M-D\"\n      | \"D&A\" | \"D&M\"\n      | \"D|A\" | \"D|M\"\n      | \"D\" | \"A\" | \"M\"\n\n\n  jmp = semi (\"JGT\" | \"JEQ\" | \"JGE\" | \"JLT\" | \"JNE\" | \"JLE\" | \"JMP\")\n}`;\nexport default asm;\n","import { assertExists } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport ohm from \"ohm-js\";\nimport {\n  ASSIGN,\n  ASSIGN_ASM,\n  ASSIGN_OP,\n  COMMANDS,\n  COMMANDS_ASM,\n  COMMANDS_OP,\n  JUMP,\n  JUMP_ASM,\n  JUMP_OP,\n} from \"../cpu/alu.js\";\nimport { KEYBOARD_OFFSET, SCREEN_OFFSET } from \"../cpu/memory.js\";\nimport { makeC } from \"../util/asm.js\";\nimport { grammars, makeParser, baseSemantics } from \"./base.js\";\n\nimport asmGrammar from \"./grammars/asm.ohm.js\";\n\nexport const grammar = ohm.grammar(asmGrammar, grammars);\nexport const asmSemantics = grammar.extendSemantics(baseSemantics);\n\nexport interface Asm {\n  instructions: AsmInstruction[];\n}\n\nexport type AsmInstruction =\n  | AsmAInstruction\n  | AsmCInstruction\n  | AsmLabelInstruction;\n\nexport type AsmAInstruction = AsmALabelInstruction | AsmAValueInstruction;\nexport interface AsmALabelInstruction {\n  type: \"A\";\n  label: string;\n}\n\nexport interface AsmAValueInstruction {\n  type: \"A\";\n  value: number;\n}\n\nfunction isALabelInstruction(\n  inst: AsmAInstruction\n): inst is AsmALabelInstruction {\n  return (inst as AsmALabelInstruction).label !== undefined;\n}\n\nexport interface AsmCInstruction {\n  type: \"C\";\n  op: COMMANDS_OP;\n  isM: boolean;\n  store?: ASSIGN_OP;\n  jump?: JUMP_OP;\n}\n\nexport interface AsmLabelInstruction {\n  type: \"L\";\n  label: string;\n}\n\nasmSemantics.addAttribute<Asm>(\"root\", {\n  Root(_) {\n    return this.asm;\n  },\n});\n\nasmSemantics.addAttribute<Asm>(\"asm\", {\n  Root(asm) {\n    return {\n      instructions: asm\n        .child(0)\n        .children.map(({ instruction }) => instruction as AsmInstruction),\n    };\n  },\n});\n\nasmSemantics.addAttribute<AsmInstruction>(\"instruction\", {\n  AInstruction(_at, val): AsmAInstruction {\n    try {\n      return {\n        type: \"A\",\n        label: val.name,\n      };\n    } catch (e) {\n      // Pass\n    }\n\n    try {\n      return {\n        type: \"A\",\n        value: val.value,\n      };\n    } catch (e) {\n      // pass\n    }\n\n    throw new Error(`AsmAInstruction must have either a name or a value`);\n  },\n  CInstruction(assignN, opN, jmpN): AsmCInstruction {\n    const assign = assignN.child(0)?.child(0)?.sourceString as ASSIGN_ASM;\n    const op = opN.sourceString.replace(\"M\", \"A\") as COMMANDS_ASM;\n    const jmp = jmpN.child(0)?.child(1)?.sourceString as JUMP_ASM;\n    const isM =\n      assignN.sourceString.includes(\"M\") || opN.sourceString.includes(\"M\");\n    const inst: AsmCInstruction = {\n      type: \"C\",\n      op: COMMANDS.asm[op],\n      isM,\n    };\n    if (jmp) inst.jump = JUMP.asm[jmp];\n    if (assign) inst.store = ASSIGN.asm[assign];\n    return inst;\n  },\n  Label(_o, { name }, _c): AsmLabelInstruction {\n    return {\n      type: \"L\",\n      label: name,\n    };\n  },\n});\n\nexport function fillLabel(asm: Asm) {\n  let nextLabel = 16;\n  const symbols = new Map<string, number>([\n    [\"R0\", 0],\n    [\"R1\", 1],\n    [\"R2\", 2],\n    [\"R3\", 3],\n    [\"R4\", 4],\n    [\"R5\", 5],\n    [\"R6\", 6],\n    [\"R7\", 7],\n    [\"R8\", 8],\n    [\"R9\", 9],\n    [\"R10\", 10],\n    [\"R11\", 11],\n    [\"R12\", 12],\n    [\"R13\", 13],\n    [\"R14\", 14],\n    [\"R15\", 15],\n    [\"SP\", 0],\n    [\"LCL\", 1],\n    [\"ARG\", 2],\n    [\"THIS\", 3],\n    [\"THAT\", 4],\n    [\"SCREEN\", SCREEN_OFFSET],\n    [\"KBD\", KEYBOARD_OFFSET],\n  ]);\n\n  function getLabelValue(label: string) {\n    if (!symbols.has(label)) {\n      symbols.set(label, nextLabel);\n      nextLabel += 1;\n    }\n    return assertExists(symbols.get(label), `Label not in symbols: ${label}`);\n  }\n\n  function transmuteAInstruction(instruction: AsmALabelInstruction) {\n    const value = getLabelValue(instruction.label);\n    (instruction as unknown as AsmAValueInstruction).value = value;\n    delete (instruction as unknown as { label: undefined }).label;\n  }\n\n  const unfilled: AsmALabelInstruction[] = [];\n  let line = 0;\n  for (const instruction of asm.instructions) {\n    if (instruction.type === \"L\") {\n      if (symbols.has(instruction.label)) {\n        throw new Error(`ASM Duplicate label ${instruction.label}`);\n      } else {\n        symbols.set(instruction.label, line);\n      }\n      continue;\n    }\n\n    line += 1;\n\n    if (instruction.type === \"A\") {\n      if (isALabelInstruction(instruction)) {\n        unfilled.push(instruction);\n      }\n    }\n  }\n\n  unfilled.forEach(transmuteAInstruction);\n}\n\nexport function emit(asm: Asm): number[] {\n  return asm.instructions\n    .map((inst) => {\n      if (inst.type === \"A\") {\n        if (isALabelInstruction(inst)) {\n          throw new Error(`ASM Emitting unfilled A instruction`);\n        }\n        return inst.value;\n      }\n      if (inst.type === \"C\") {\n        return makeC(inst.isM, inst.op, inst.store, inst.jump);\n      }\n      return undefined;\n    })\n    .filter((op): op is number => op !== undefined);\n}\n\nexport const ASM = {\n  grammar: asmGrammar,\n  semantics: asmSemantics,\n  parser: grammar,\n  parse: makeParser<Asm>(grammar, asmSemantics),\n  passes: {\n    fillLabel,\n    emit,\n  },\n};\n","import { unwrap } from \"@davidsouther/jiffies/lib/esm/result.js\";\nimport { ASM } from \"./languages/asm.js\";\nimport { int2, parseTwosInt } from \"./util/twos.js\";\n\nexport async function loadAsm(source: string): Promise<number[]> {\n  const asm = unwrap(ASM.parse(source));\n  ASM.passes.fillLabel(asm);\n  return ASM.passes.emit(asm);\n}\n\nexport async function loadHack(source: string): Promise<number[]> {\n  return source\n    .split(\"\\n\")\n    .filter((line) => line.trim() !== \"\")\n    .map(int2);\n}\n\nexport async function loadBlob(bytes: string): Promise<number[]> {\n  return bytes\n    .split(\"\\n\")\n    .filter((line) => line.trim() !== \"\")\n    .map(parseTwosInt);\n}\n","import { assert } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { bin, dec, hex } from \"./util/twos.js\";\nimport { Test } from \"./tst.js\";\n\nexport class Output {\n  private readonly fmt: \"B\" | \"X\" | \"D\" | \"S\";\n  private readonly lPad: number;\n  private readonly rPad: number;\n  private readonly len: number;\n  private readonly index: number;\n  private readonly builtin: boolean;\n\n  // new Output(inst.id, inst.style, inst.width, inst.lpad, inst.rpad)\n  constructor(\n    private variable: string,\n    format = \"%B1.1.1\",\n    len?: number,\n    lPad?: number,\n    rPad?: number,\n    builtin?: boolean,\n    index?: number\n  ) {\n    if (\n      format.startsWith(\"%\") &&\n      len === undefined &&\n      lPad === undefined &&\n      rPad === undefined\n    ) {\n      const { fmt, lPad, rPad, len } = format.match(\n        /^%(?<fmt>[BDXS])(?<lPad>\\d+)\\.(?<len>\\d+)\\.(?<rPad>\\d+)$/\n      )?.groups as {\n        fmt: \"B\" | \"X\" | \"D\" | \"S\";\n        lPad: string;\n        rPad: string;\n        len: string;\n      };\n      this.fmt = fmt;\n      this.lPad = parseInt(lPad);\n      this.rPad = parseInt(rPad);\n      this.len = parseInt(len);\n      this.builtin = false;\n      this.index = -1;\n    } else {\n      assert([\"B\", \"X\", \"D\", \"S\"].includes(format[0]));\n      this.fmt = format[0] as \"B\" | \"X\" | \"D\" | \"S\";\n      this.len = len ?? 3;\n      this.lPad = lPad ?? 1;\n      this.rPad = rPad ?? 1;\n      this.builtin = builtin ?? false;\n      this.index = index ?? -1;\n    }\n  }\n\n  header(test: Test) {\n    let variable = `${this.variable}`;\n    if (this.builtin) {\n      const index = this.index >= 0 ? this.index : \"\";\n      variable = `${variable}[${index}]`;\n    }\n    if (variable.length > this.len + this.lPad + this.rPad) {\n      return variable.substring(0, this.len + this.lPad + this.rPad);\n    }\n    return this.padCenter(variable);\n  }\n\n  print(test: Test) {\n    const val = test.getVar(this.variable, this.index);\n    if (this.fmt === \"S\") {\n      return this.padLeft(val as string);\n    }\n\n    const fmt = { B: bin, D: dec, X: hex }[this.fmt];\n    const value = fmt(val as number);\n    if (this.fmt === \"D\") {\n      return this.padRight(value);\n    } else {\n      return this.padCenter(value.slice(value.length - this.len));\n    }\n  }\n\n  private padCenter(value: string) {\n    const space = this.lPad + this.len + this.rPad;\n    const leftSpace = Math.floor((space - value.length) / 2);\n    const rightSpace = space - leftSpace - value.length;\n    const padLeft = leftSpace + value.length;\n    const padRight = padLeft + rightSpace;\n    value = value.padStart(padLeft);\n    value = value.padEnd(padRight);\n    return value;\n  }\n\n  private padLeft(value: string) {\n    value = value.substring(0, this.len);\n    const padRight = this.rPad + this.len;\n    const padLeft = this.lPad + padRight;\n    value = value.padEnd(padRight);\n    value = value.padStart(padLeft);\n    return value;\n  }\n\n  private padRight(value: string) {\n    value = value.substring(0, this.len);\n    const padLeft = this.lPad + this.len;\n    const padRight = this.rPad + padLeft;\n    value = value.padStart(padLeft);\n    value = value.padEnd(padRight);\n    return value;\n  }\n}\n","import {\n  assertExists,\n  checkExhaustive,\n} from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport { Span } from \"./languages/base.js\";\nimport {\n  Tst,\n  TstLineStatement,\n  TstOperation,\n  TstOutputSpec,\n  TstStatement,\n  TstWhileStatement,\n} from \"./languages/tst.js\";\nimport { Bus, Chip, HIGH, Low, LOW } from \"./chip/chip.js\";\nimport { Clock } from \"./chip/clock.js\";\nimport { Output } from \"./output.js\";\nimport { ROM } from \"./cpu/memory.js\";\nimport { CPU } from \"./cpu/cpu.js\";\n\nexport abstract class Test<IS extends TestInstruction = TestInstruction> {\n  protected readonly instructions: (IS | TestInstruction)[] = [];\n  protected _outputList: Output[] = [];\n  protected _log = \"\";\n  fs: FileSystem = new FileSystem();\n\n  setFileSystem(fs: FileSystem): this {\n    this.fs = fs;\n    return this;\n  }\n\n  echo(_content: string) {\n    return undefined;\n  }\n  clearEcho() {\n    return undefined;\n  }\n\n  async load(_filename: string): Promise<void> {\n    return undefined;\n  }\n  async compareTo(_filename: string): Promise<void> {\n    return undefined;\n  }\n  outputFile(_filename: string): void {\n    return undefined;\n  }\n  outputList(outputs: Output[]): void {\n    this._outputList = outputs;\n  }\n\n  addInstruction(instruction: IS | TestInstruction): void {\n    this.instructions.push(instruction);\n  }\n\n  reset(): this {\n    this._steps = (function* (test) {\n      for (const instruction of test.instructions) {\n        yield* instruction.steps(test);\n      }\n    })(this);\n    this._step = this._steps.next();\n    this._step; //?\n    this._log = \"\";\n    return this;\n  }\n\n  private _steps!: IterableIterator<IS | TestInstruction>;\n  private _step!: IteratorResult<IS | TestInstruction, IS | TestInstruction>;\n\n  get steps(): Iterator<IS | TestInstruction> {\n    if (this._steps === undefined) {\n      this.reset();\n      this._steps = assertExists(this._steps, \"Reset did not initialize steps\");\n      this._step = assertExists(this._step, \"Reset did not find first step\");\n    }\n    return this._steps;\n  }\n\n  get currentStep(): IS | TestInstruction | undefined {\n    return this._step?.value;\n  }\n\n  get done(): boolean {\n    return this._step?.done ?? false;\n  }\n\n  step() {\n    if (!this._step.done) {\n      this._step.value.do(this);\n      this._step = this.steps.next();\n      return false;\n    }\n    return true;\n  }\n\n  async run() {\n    this.reset();\n    while (!(await this.step()));\n  }\n\n  protected readonly breakpoints: Map<string, number> = new Map();\n  addBreakpoint(variable: string, value: number) {\n    this.breakpoints.set(variable, value);\n  }\n  clearBreakpoints() {\n    this.breakpoints.clear();\n  }\n\n  output() {\n    const values = this._outputList.map((output) => output.print(this));\n    this._log += `|${values.join(\"|\")}|\\n`;\n  }\n\n  header() {\n    const values = this._outputList.map((output) => output.header(this));\n    this._log += `|${values.join(\"|\")}|\\n`;\n  }\n\n  log() {\n    return this._log;\n  }\n\n  abstract hasVar(variable: string | number): boolean;\n  abstract getVar(variable: string | number, offset?: number): number | string;\n  abstract setVar(variable: string, value: number, offset?: number): void;\n}\n\nfunction isTstLineStatment(line: TstStatement): line is TstLineStatement {\n  return (line as TstLineStatement).ops !== undefined;\n}\n\nfunction isTstWhileStatement(line: TstStatement): line is TstWhileStatement {\n  return (line as TstWhileStatement).condition !== undefined;\n}\n\nfunction makeLineStatement(line: TstLineStatement) {\n  const statement = new TestCompoundInstruction();\n  statement.span = line.span;\n  for (const op of line.ops) {\n    const inst = makeInstruction(op);\n    if (inst !== undefined) statement.addInstruction(inst);\n  }\n  return statement;\n}\n\nfunction makeInstruction(inst: TstOperation) {\n  const { op } = inst;\n  switch (op) {\n    case \"tick\":\n      return new TestTickInstruction();\n    case \"tock\":\n      return new TestTockInstruction();\n    case \"eval\":\n      return new TestEvalInstruction();\n    case \"output\":\n      return new TestOutputInstruction();\n    case \"set\":\n      return new TestSetInstruction(inst.id, inst.value, inst.index);\n    case \"output-list\":\n      return new TestOutputListInstruction(inst.spec);\n    case \"echo\":\n      return new TestEchoInstruction(inst.message);\n    case \"clear-echo\":\n      return new TestClearEchoInstruction();\n    case \"loadRom\":\n      return new TestLoadROMInstruction(inst.file);\n    case \"load\":\n    case \"output-file\":\n    case \"compare-to\":\n      return undefined;\n    default:\n      checkExhaustive(op, `Unknown tst operation ${op}`);\n  }\n}\n\nfunction fill<T extends Test>(test: T, tst: Tst): T {\n  for (const line of tst.lines) {\n    if (isTstLineStatment(line)) {\n      test.addInstruction(makeLineStatement(line));\n    } else {\n      const repeat = isTstWhileStatement(line)\n        ? new TestWhileInstruction(\n            new Condition(\n              line.condition.left,\n              line.condition.right,\n              line.condition.op\n            )\n          )\n        : new TestRepeatInstruction(line.count);\n      repeat.span = line.span;\n      test.addInstruction(repeat);\n      for (const statement of line.statements) {\n        repeat.addInstruction(makeLineStatement(statement));\n      }\n    }\n  }\n\n  test.reset();\n\n  return test;\n}\n\nexport class ChipTest extends Test<ChipTestInstruction> {\n  private chip: Chip = new Low();\n  get chipId(): number {\n    return this.chip.id;\n  }\n\n  private clock = Clock.get();\n\n  static from(tst: Tst): ChipTest {\n    const test = new ChipTest();\n    return fill(test, tst);\n  }\n\n  with(chip: Chip): this {\n    this.chip = chip;\n    return this;\n  }\n\n  hasVar(variable: string | number): boolean {\n    if (variable === \"time\") {\n      return true;\n    }\n    variable = `${variable}`;\n    // Look up built-in chip state variables\n    return this.chip.hasIn(variable) || this.chip.hasOut(variable);\n  }\n\n  getVar(variable: string | number, offset?: number): number | string {\n    variable = `${variable}`;\n    if (variable === \"time\") {\n      return this.clock.toString();\n    }\n    const pin = this.chip.get(variable, offset);\n    if (!pin) return 0;\n    return pin instanceof Bus ? pin.busVoltage : pin.voltage();\n  }\n\n  setVar(variable: string, value: number, offset?: number): void {\n    // Look up built-in chip state variables\n    const pinOrBus = this.chip.get(variable, offset);\n    if (pinOrBus instanceof Bus) {\n      pinOrBus.busVoltage = value;\n    } else {\n      pinOrBus?.pull(value === 0 ? LOW : HIGH);\n    }\n  }\n\n  eval(): void {\n    this.chip.eval();\n  }\n\n  tick(): void {\n    this.chip.eval();\n    this.clock.tick();\n  }\n\n  tock(): void {\n    this.chip.eval();\n    this.clock.tock();\n  }\n\n  override async load(filename: string) {\n    await this.chip.load(this.fs, filename);\n  }\n\n  override async run() {\n    this.clock.reset();\n    await super.run();\n  }\n}\n\nexport class CPUTest extends Test<CPUTestInstruction> {\n  readonly cpu: CPU;\n  private ticks = 0;\n\n  static from(tst: Tst): CPUTest {\n    const test = new CPUTest();\n    return fill(test, tst);\n  }\n\n  constructor(rom: ROM = new ROM(new Int16Array())) {\n    super();\n    this.cpu = new CPU({ ROM: rom });\n    this.reset();\n  }\n\n  override reset(): this {\n    this.cpu.reset();\n    this.ticks = 0;\n    return this;\n  }\n\n  hasVar(variable: string | number): boolean {\n    if (typeof variable === \"number\") {\n      return false;\n    }\n    // A: Current value of the address register (unsigned 15-bit);\n    // D: Current value of the data register (16-bit);\n    // PC: Current value of the Program Counter (unsigned 15-bit);\n    // RAM[i]: Current value of RAM location i (16-bit);\n    // time: Number of time units (also called clock cycles, or ticktocks) that elapsed since the simulation started (a read-only system variable).\n    if (\n      variable === \"A\" ||\n      variable === \"D\" ||\n      variable === \"PC\" ||\n      variable === \"time\" ||\n      variable.startsWith(\"RAM\")\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  getVar(variable: string | number): number {\n    switch (variable) {\n      case \"A\":\n        return this.cpu.A;\n      case \"D\":\n        return this.cpu.D;\n      case \"PC\":\n        return this.cpu.PC;\n      case \"time\":\n        return this.ticks;\n    }\n    if (typeof variable === \"number\") return 0;\n    if (variable.startsWith(\"RAM\")) {\n      const num = Number(variable.substring(4, variable.length - 1));\n      return this.cpu.RAM.get(num);\n    }\n    return 0;\n  }\n\n  setVar(variable: string, value: number, index?: number): void {\n    // A: Current value of the address register (unsigned 15-bit);\n    // D: Current value of the data register (16-bit);\n    // PC: Current value of the Program Counter (unsigned 15-bit);\n    // RAM[i]: Current value of RAM location i (16-bit);\n    switch (variable) {\n      case \"A\":\n        this.cpu.setA(value);\n        break;\n      case \"D\":\n        this.cpu.setD(value);\n        break;\n      case \"PC\":\n        this.cpu.setPC(value);\n        break;\n      case \"RAM\":\n        this.cpu.RAM.set(index ?? 0, value);\n        break;\n    }\n    return;\n  }\n\n  ticktock(): void {\n    this.ticks += 1;\n    this.cpu.tick();\n  }\n\n  override async load(filename: string): Promise<void> {\n    await this.cpu.ROM.load(this.fs, filename);\n  }\n}\n\nexport class VMTest extends Test<VMTestInstruction> {\n  hasVar(_variable: string | number): boolean {\n    return false;\n  }\n  getVar(_variable: string | number): number {\n    return 0;\n  }\n  setVar(_variable: string, _value: number): void {\n    return undefined;\n  }\n  vmstep(): void {\n    return undefined;\n  }\n}\n\nexport interface TestInstruction {\n  span?: Span;\n  do(test: Test): void;\n  steps(test: Test): IterableIterator<TestInstruction>;\n}\n\nexport class TestSetInstruction implements TestInstruction {\n  constructor(\n    private variable: string,\n    private value: number,\n    private index?: number | undefined\n  ) {}\n\n  do(test: Test) {\n    test.setVar(this.variable, this.value, this.index);\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestOutputInstruction implements TestInstruction {\n  do(test: Test) {\n    test.output();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestOutputListInstruction implements TestInstruction {\n  private outputs: Output[] = [];\n\n  constructor(specs: TstOutputSpec[] = []) {\n    for (const spec of specs) {\n      this.addOutput(spec);\n    }\n  }\n\n  addOutput(inst: TstOutputSpec) {\n    this.outputs.push(\n      new Output(\n        inst.id,\n        inst.style,\n        inst.width,\n        inst.lpad,\n        inst.rpad,\n        inst.builtin,\n        inst.address\n      )\n    );\n  }\n\n  do(test: Test) {\n    test.outputList(this.outputs);\n    test.header();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestCompoundInstruction implements TestInstruction {\n  protected readonly instructions: TestInstruction[] = [];\n  span?: Span;\n\n  addInstruction(instruction: TestInstruction) {\n    this.instructions.push(instruction);\n  }\n\n  do(test: Test<TestInstruction>): void {\n    for (const instruction of this.instructions) {\n      instruction.do(test);\n    }\n  }\n\n  *steps(_test: Test): Generator<TestInstruction> {\n    yield this;\n  }\n}\n\nexport class TestRepeatInstruction extends TestCompoundInstruction {\n  constructor(public readonly repeat: number) {\n    super();\n  }\n\n  override do() {\n    return undefined;\n  }\n\n  private *innerSteps(test: Test) {\n    for (const instruction of this.instructions) {\n      yield* instruction.steps(test);\n    }\n  }\n\n  override *steps(test: Test) {\n    if (this.repeat === -1) {\n      yield this;\n      while (true) {\n        yield* this.innerSteps(test);\n      }\n    } else {\n      for (let i = 0; i < this.repeat; i++) {\n        yield this;\n        yield* this.innerSteps(test);\n      }\n    }\n  }\n}\n\nexport class Condition {\n  constructor(\n    public readonly x: string | number,\n    public readonly y: string | number,\n    public readonly op: \"<\" | \"<=\" | \"=\" | \">=\" | \">\" | \"<>\"\n  ) {}\n\n  check(test: Test): boolean {\n    const x = test.hasVar(this.x) ? test.getVar(this.x) : this.x;\n    const y = test.hasVar(this.y) ? test.getVar(this.y) : this.y;\n\n    if (typeof x === \"string\" || typeof y === \"string\") {\n      switch (this.op) {\n        case \"=\":\n          return `${x}` === `${y}`;\n        case \"<>\":\n          return `${x}` !== `${y}`;\n      }\n    } else {\n      switch (this.op) {\n        case \"<\":\n          return x < y;\n        case \"<=\":\n          return x <= y;\n        case \">\":\n          return x > y;\n        case \">=\":\n          return x >= y;\n        case \"=\":\n          return x === y;\n        case \"<>\":\n          return x !== y;\n      }\n    }\n    return false;\n  }\n}\n\nexport class TestWhileInstruction extends TestCompoundInstruction {\n  constructor(public readonly condition: Condition) {\n    super();\n  }\n\n  override *steps(test: Test) {\n    while (this.condition.check(test)) {\n      yield this;\n      for (const instruction of this.instructions) {\n        yield* instruction.steps(test);\n      }\n    }\n  }\n}\n\nexport class TestEchoInstruction implements TestInstruction {\n  constructor(public readonly content: string) {}\n  do(test: Test) {\n    test.echo(this.content);\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestClearEchoInstruction implements TestInstruction {\n  do(test: Test) {\n    test.clearEcho();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestLoadROMInstruction implements TestInstruction {\n  constructor(readonly file: string) {}\n  async do(test: Test) {\n    test.fs.pushd(\"/test\");\n    await test.load(this.file);\n    test.fs.popd();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestBreakpointInstruction implements TestInstruction {\n  constructor(readonly variable: string, readonly value: number) {}\n\n  do(test: Test) {\n    test.addBreakpoint(this.variable, this.value);\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestClearBreakpointsInstruction implements TestInstruction {\n  do(test: Test) {\n    test.clearBreakpoints();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport interface ChipTestInstruction extends TestInstruction {\n  _chipTestInstruction_: true;\n  do(test: ChipTest): void | Promise<void>;\n}\n\nexport class TestEvalInstruction implements ChipTestInstruction {\n  readonly _chipTestInstruction_ = true;\n  do(test: ChipTest) {\n    test.eval();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestTickInstruction implements ChipTestInstruction {\n  readonly _chipTestInstruction_ = true;\n  do(test: ChipTest) {\n    test.tick();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestTockInstruction implements ChipTestInstruction {\n  readonly _chipTestInstruction_ = true;\n  do(test: ChipTest) {\n    test.tock();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport interface CPUTestInstruction extends TestInstruction {\n  _cpuTestInstruction_: true;\n  do(test: CPUTest): void | Promise<void>;\n}\n\nexport class TestTickTockInstruction implements CPUTestInstruction {\n  readonly _cpuTestInstruction_ = true;\n  do(test: CPUTest) {\n    test.ticktock();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport interface VMTestInstruction extends TestInstruction {\n  _vmTestInstruction_: true;\n  do(test: VMTest): void | Promise<void>;\n}\n\nexport class TestVMStepInstruction implements VMTestInstruction {\n  readonly _vmTestInstruction_ = true;\n  do(test: VMTest) {\n    test.vmstep();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n","import {\n  ASSIGN,\n  ASSIGN_ASM,\n  ASSIGN_OP,\n  COMMANDS,\n  COMMANDS_ASM,\n  COMMANDS_OP,\n  JUMP,\n  JUMP_ASM,\n  JUMP_OP,\n} from \"../cpu/alu.js\";\n\nexport type CommandOps = keyof typeof COMMANDS.op;\nexport type JumpOps = keyof typeof JUMP.op;\nexport type StoreOps = keyof typeof ASSIGN.op;\n\nexport function asm(op: number): string {\n  if (op & 0x8000) {\n    return cInstruction(op);\n  }\n  return aInstruction(op);\n}\n\nfunction cInstruction(op: number): string {\n  op = op & 0xffff; // Clear high order bits\n  const mop = (op & 0x1000) >> 12;\n  const cop: CommandOps = ((op & 0b0000111111000000) >> 6) as CommandOps;\n  const sop: StoreOps = ((op & 0b0000000000111000) >> 3) as StoreOps;\n  const jop: JumpOps = (op & 0b0000000000000111) as JumpOps;\n\n  if (COMMANDS.op[cop] === undefined) {\n    // Invalid commend\n    return \"#ERR\";\n  }\n\n  let command = COMMANDS.op[cop];\n  if (mop) {\n    command = command.replace(/A/g, \"M\") as COMMANDS_ASM;\n  }\n\n  const store = ASSIGN.op[sop];\n  const jump = JUMP.op[jop];\n\n  let instruction: string = command;\n  if (store) {\n    instruction = `${store}=${instruction}`;\n  }\n  if (jump) {\n    instruction = `${instruction};${jump}`;\n  }\n\n  return instruction;\n}\n\nfunction aInstruction(op: number): string {\n  return \"@\" + (op & 0x7fff).toString(10);\n}\n\nexport function op(asm: string): number {\n  if (asm[0] === \"@\") {\n    return aop(asm);\n  } else {\n    return cop(asm);\n  }\n}\n\nfunction aop(asm: string): number {\n  return parseInt(asm.substring(1), 10);\n}\n\nfunction cop(asm: string): number {\n  const parts = asm.match(\n    /(?:(?<assign>[AMD]{1,3})=)?(?<operation>[-!01ADM&|]{1,3})(?:;(?<jump>JGT|JLT|JGE|JLE|JEQ|JMP))?/\n  );\n  const { assign, operation, jump } = parts?.groups ?? {};\n  const mode = operation.includes(\"M\") || assign.includes(\"M\");\n  const aop = ASSIGN.asm[(assign as ASSIGN_ASM) ?? \"\"];\n  const jop = JUMP.asm[(jump as JUMP_ASM) ?? \"\"];\n  const cop = COMMANDS.asm[(operation as COMMANDS_ASM) ?? \"\"];\n\n  return makeC(mode, cop, aop, jop);\n}\n\nexport function makeC(\n  isM: boolean,\n  op: COMMANDS_OP,\n  assign: ASSIGN_OP = 0,\n  jmp: JUMP_OP = 0\n): number {\n  const C = 0xe000;\n  const A = isM ? 0x1000 : 0;\n  const O = op << 6;\n  const D = (assign ?? 0) << 3;\n  const J = jmp ?? 0;\n  return C + A + O + D + J;\n}\n","const Hex = [\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n];\n\nexport function chars(i: number): string {\n  return Hex[i] ?? \"X\";\n}\n\nexport function bits(i: number): string {\n  switch (i) {\n    case 0x0:\n      return \"0000\";\n    case 0x1:\n      return \"0001\";\n    case 0x2:\n      return \"0010\";\n    case 0x3:\n      return \"0011\";\n    case 0x4:\n      return \"0100\";\n    case 0x5:\n      return \"0101\";\n    case 0x6:\n      return \"0110\";\n    case 0x7:\n      return \"0111\";\n    case 0x8:\n      return \"1000\";\n    case 0x9:\n      return \"1001\";\n    case 0xa:\n      return \"1010\";\n    case 0xb:\n      return \"1011\";\n    case 0xc:\n      return \"1100\";\n    case 0xd:\n      return \"1101\";\n    case 0xe:\n      return \"1110\";\n    case 0xf:\n      return \"1111\";\n    default:\n      return \"erro\";\n  }\n}\n\nexport function int(n: string, radix: number): number {\n  const i = parseInt(n.replace(/[^\\d a-f A-F +-.]/g, \"\"), radix);\n  return i & 0xffff;\n}\n\nexport function int16(i: string): number {\n  return int(i, 16);\n}\n\nexport function int10(i: string): number {\n  return int(i, 10);\n}\n\nexport function int2(i: string): number {\n  return int(i.replaceAll(\" \", \"\"), 2);\n}\n\nexport function parseTwosInt(i: string): number {\n  if (i.toUpperCase().includes(\"X\")) {\n    return int16(i);\n  }\n  return int10(i);\n}\n\nexport function hex(i: number): string {\n  const hu = chars((i & 0xf000) >> 12);\n  const hl = chars((i & 0x0f00) >> 8);\n  const lu = chars((i & 0x00f0) >> 4);\n  const ll = chars(i & 0x000f);\n\n  return `0x${hu}${hl}${lu}${ll}`;\n}\n\nexport function bin(i: number, precision = 16): string {\n  const hu = bits((i & 0xf000) >> 12);\n  const hl = bits((i & 0x0f00) >> 8);\n  const lu = bits((i & 0x00f0) >> 4);\n  const ll = bits(i & 0x000f);\n\n  // return `${hu} ${hl} ${lu} ${ll}`;\n  return `${hu}${hl}${lu}${ll}`.substring(16 - precision); // Match the book's formatting\n}\n\nexport function dec(i: number): string {\n  i = i & 0xffff;\n  if (i === 0x8000) {\n    return \"-32768\";\n  }\n  if (i & 0x8000) {\n    i = (~i + 1) & 0x7fff;\n    return `-${i}`;\n  }\n  return `${i}`;\n}\n\nexport function uns(i: number): string {\n  i = i & 0xffff;\n  return `${i}`;\n}\n\nexport function nand16(a: number, b: number): number {\n  a = a & 0xffff;\n  b = b & 0xffff;\n  let c = ~(a & b);\n  c = c & 0xffff;\n  return c;\n}\n"],"names":["DiffTable","className","out","cmp","zeroState","output","CMP","compare","isErr","_jsxs","children","_jsx","display","Err","cmpData","Ok","outData","failures","table","range","Math","min","length","map","i","cmpI","outI","max","_","j","cell","pass","trim","match","style","fontFamily","marginBottom","row","DiffCell","HIGH","LOW","Bus","name","width","state","next","constructor","this","ensureWidth","newWidth","assert","connect","push","busVoltage","pull","voltage","bit","forEach","n","reduce","b","toggle","nextVoltage","InSubBus","bus","start","super","high","mask","low","mid","OutSubBus","ConstantBus","value","pullHigh","pullLow","TRUE_BUS","FALSE_BUS","parsePinDecl","toPin","pin","w","groups","Number","Pins","Map","insert","has","set","emplace","minWidth","get","entries","values","Symbol","iterator","id","Chip","ins","outs","pins","parts","Set","clockedPins","clocked","size","part","internals","inn","undefined","internal","Clock","$","subscribe","eval","reset","in","hasIn","hasOut","offset","getBuiltin","BUILTIN_NAMES","includes","isOutPin","wire","connections","add","to","from","wireOutPin","wireInPin","findPin","toLowerCase","partPin","assertExists","chipPin","isInternal","Error","chip","tick","tock","remove","async","fs","path","load","Low","ClockedChip","level","unsubscribe","pow","clock","ticks","static","isHigh","isLow","subject","BehaviorSubject","frameSubject","Subject","resetSubject","frame$","reset$","frame","toString","COMMANDS_ALU","op","COMMANDS","asm","D","A","M","ASSIGN","MD","AM","AD","AMD","JUMP","JGT","JEQ","JGE","JLT","JNE","JLE","JMP","Flags","Positive","Zero","Negative","alu","d","a","o","emptyState","PC","ALU","flag","BITS","decode","instruction","c","x1","x2","am","d1","d2","d3","j1","j2","j3","cpuTick","inM","bits","cpuTock","oldA","alu2","addressM","outM","writeM","CPU","RAM","ROM","Screen","Keyboard","setA","setD","setPC","RAMMem","SubMemory","SCREEN_SIZE","SCREEN_OFFSET","MemoryKeyboard","input","tickState","_writeM","cpu","FORMATS","SCREEN_ROWS","KEYBOARD_OFFSET","Memory","memory","Int16Array","index","fill","update","format","current","int2","int16","int10","isFinite","loadBytes","cause","bytes","end","slice","fn","parent","getKey","setKey","key","clearKey","program","arr","SIZE","endsWith","loader","readFile","loadHack","loadAsm","UNKNOWN_PARSE_ERROR","grammars","Base","ohm","baseSemantics","createSemantics","makeParser","grammar","semantics","property","root","source","succeeded","parsed","parse","message","shortMessage","e","extendOperation","List","list","asIteration","addAttribute","decNumber","digits","sourceString","wholeDec","binNumber","hexNumber","num","Name","ident","identifier","__","child","String","_a","str","_b","cmpGrammar","cmpSemantics","extendSemantics","line","cells","Root","lines","parser","tstGrammar","tstSemantics","extendAttribute","Index","idx","FileName","_open","dec","_close","OutputFormat","_c","lpad","rpad","builtin","address","TstEvalOperation","TstOutputOperation","TstOutputListOperation","formats","spec","TstSetOperation","setOp","TstEchoOperation","TstClearEchoOperation","TstLoadROMOperation","_r","_l","file","TstFileOperation","Condition","left","right","TstWhile","cond","_o","statements","statement","condition","span","startIdx","endIdx","TstRepeat","count","TstStatement","stmt","ops","node","operation","break","Tst","tst","TST","asmGrammar","asmSemantics","isALabelInstruction","inst","label","instructions","AInstruction","_at","val","type","CInstruction","assignN","opN","jmpN","assign","replace","jmp","isM","jump","store","Label","ASM","passes","fillLabel","nextLabel","symbols","unfilled","emit","makeC","filter","unwrap","split","loadBlob","parseTwosInt","Output","variable","fmt","lPad","rPad","len","startsWith","parseInt","header","test","substring","padCenter","print","getVar","padLeft","B","bin","X","hex","padRight","space","leftSpace","floor","rightSpace","padStart","padEnd","Test","_outputList","_log","FileSystem","setFileSystem","echo","_content","clearEcho","_filename","outputFile","outputList","outputs","addInstruction","_steps","steps","_step","currentStep","done","step","do","breakpoints","addBreakpoint","clearBreakpoints","clear","join","log","isTstLineStatment","isTstWhileStatement","makeLineStatement","TestCompoundInstruction","makeInstruction","TestTickInstruction","TestTockInstruction","TestEvalInstruction","TestOutputInstruction","TestSetInstruction","TestOutputListInstruction","TestEchoInstruction","TestClearEchoInstruction","TestLoadROMInstruction","checkExhaustive","repeat","TestWhileInstruction","TestRepeatInstruction","ChipTest","chipId","with","hasVar","setVar","pinOrBus","filename","run","CPUTest","rom","ticktock","specs","addOutput","_test","innerSteps","x","y","check","content","pushd","popd","_chipTestInstruction_","mop","cop","sop","jop","command","cInstruction","aInstruction","aop","mode","C","O","J","Hex","chars","int","radix","replaceAll","toUpperCase","precision","hu","hl","lu","ll","uns","nand16"],"sourceRoot":""}