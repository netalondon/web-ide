"use strict";(globalThis.webpackChunk_nand2tetris_web=globalThis.webpackChunk_nand2tetris_web||[]).push([[157,597],{8157:(e,i,t)=>{t.r(i);var r=t(4269),n=t(6042),s=t(9597);const{INVALID:o,GONE:a,SYNTAX:l,DISALLOWED:h}=s.s;class w{constructor(e,i,t,r){this.fileHandle=e,this.writer=t,this.file=r?i:new File([],i.name,i),this.size=r?i.size:0,this.position=0}async write(e){try{await this.fileHandle.getFile()}catch(w){throw new DOMException(...a)}let i=this.file;if((0,s.Z)(e))if("write"===e.type){if("number"===typeof e.position&&e.position>=0&&(this.position=e.position,this.size<e.position&&(this.file=new File([this.file,new ArrayBuffer(e.position-this.size)],this.file.name,this.file))),!("data"in e))throw new DOMException(...l("write requires a data argument"));e=e.data}else{if("seek"===e.type){if(Number.isInteger(e.position)&&e.position>=0){if(this.size<e.position)throw new DOMException(...o);return void(this.position=e.position)}throw new DOMException(...l("seek requires a position argument"))}if("truncate"===e.type){if(Number.isInteger(e.size)&&e.size>=0)return i=e.size<this.size?new File([i.slice(0,e.size)],i.name,i):new File([i,new Uint8Array(e.size-this.size)],i.name,i),this.size=i.size,this.position>i.size&&(this.position=i.size),void(this.file=i);throw new DOMException(...l("truncate requires a size argument"))}}e=new Blob([e]);let t=this.file;const r=t.slice(0,this.position),n=t.slice(this.position+e.size);let h=this.position-r.size;h<0&&(h=0),t=new File([r,new Uint8Array(h),e,n],t.name),this.size=t.size,this.position+=e.size,this.file=t}async close(){try{await this.fileHandle.getFile()}catch(i){throw new DOMException(...a)}const e=await new Promise(((e,i)=>{const t=new FileReader;t.onload=()=>e(t.result),t.onerror=i,t.readAsArrayBuffer(this.file)}));this.file=new File([e],this.file.name,this.file),await new Promise(((e,i)=>{this.writer.onwriteend=e,this.writer.onerror=i,this.writer.truncate(0)})),await new Promise(((e,i)=>{this.writer.onwriteend=e,this.writer.onerror=i,this.writer.write(this.file)})),this.writer.onwriteend=null,this.writer.onerror=null,this.file=this.position=this.size=null}}class c{constructor(e,i=!0){this.kind="file",this.readable=!0,this.file=e,this.writable=i}get name(){return this.file.name}async isSameEntry(e){return this.file.toURL()===e.file.toURL()}getFile(){return new Promise(this.file.file.bind(this.file))}async createWritable(e){if(!this.writable)throw new DOMException(...h);const i=await this.getFile();return new Promise(((t,r)=>this.file.createWriter((r=>{t(new w(this,i,r,!!e.keepExistingData))}),r)))}}class d{constructor(e,i=!0){this.kind="directory",this.readable=!0,this.dir=e,this.writable=i,this.name=e.name}async isSameEntry(e){return this.dir.fullPath===e.dir.fullPath}async*entries(){const e=this.dir.createReader(),i=await new Promise(e.readEntries.bind(e));for(const t of i)yield[t.name,t.isFile?new c(t,this.writable):new d(t,this.writable)]}getDirectoryHandle(e,i={}){return new Promise(((t,r)=>{this.dir.getDirectory(e,i,(e=>{t(new d(e))}),r)}))}getFileHandle(e,i={}){return new Promise(((t,r)=>this.dir.getFile(e,i,(e=>t(new c(e))),r)))}async removeEntry(e,i){let t;try{t=await this.getDirectoryHandle(e)}catch(r){if("TypeMismatchError"!==r.name)throw r;t=await this.getFileHandle(e)}return new Promise(((e,r)=>{t instanceof d?(null===i||void 0===i?void 0:i.recursive)?t.dir.removeRecursively((()=>e()),r):t.dir.remove((()=>e()),r):t.file&&t.file.remove((()=>e()),r)}))}}globalThis.DataTransferItem&&!globalThis.DataTransferItem.prototype.getAsFileSystemHandle&&globalThis.DataTransferItem.prototype.webkitGetAsEntry&&(globalThis.DataTransferItem.prototype.getAsFileSystemHandle=async function(){const e=this.webkitGetAsEntry();return e.isFile?new n.FileSystemFileHandle(new c(e,!1)):new r.FileSystemDirectoryHandle(new d(e,!1))})},9597:(e,i,t)=>{t.d(i,{Z:()=>n,makeDirHandleFromFileList:()=>s,makeFileHandlesFromFileList:()=>o,s:()=>r});const r={INVALID:["seeking position failed.","InvalidStateError"],GONE:["A requested file or directory could not be found at the time an operation was processed.","NotFoundError"],MISMATCH:["The path supplied exists, but was not an entry of requested type.","TypeMismatchError"],MOD_ERR:["The object can not be modified in this way.","InvalidModificationError"],SYNTAX:e=>[`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${e}`,"SyntaxError"],ABORT:["The operation was aborted","AbortError"],SECURITY:["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.","SecurityError"],DISALLOWED:["The request is not allowed by the user agent or the platform in the current context.","NotAllowedError"]},n=e=>"object"===typeof e&&"undefined"!==typeof e.type;async function s(e){var i,r,n;const{FolderHandle:s,FileHandle:o}=await t.e(807).then(t.bind(t,8807)),{FileSystemDirectoryHandle:a}=await Promise.resolve().then(t.bind(t,4269)),l=null!==(r=null===(i=e[0].webkitRelativePath)||void 0===i?void 0:i.split("/",1)[0])&&void 0!==r?r:"",h=new s(l,!1);for(let t=0;t<e.length;t++){const i=e[t],r=(null===(n=i.webkitRelativePath)||void 0===n?void 0:n.length)?i.webkitRelativePath.split("/"):["",i.name];r.shift();const a=r.pop();r.reduce(((e,i)=>(e._entries[i]||(e._entries[i]=new s(i,!1)),e._entries[i])),h)._entries[a]=new o(i.name,i,!1)}return new a(h)}async function o(e){const{FileHandle:i}=await t.e(807).then(t.bind(t,8807)),{FileSystemFileHandle:r}=await Promise.resolve().then(t.bind(t,6042));return Array.from(e).map((e=>new r(new i(e.name,e,!1))))}}}]);