{"version":3,"file":"static/js/695.4f5c9aa4.chunk.js","mappings":"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","sources":["../../simulator/src/chip/chip.tsx","../../simulator/src/chip/clock.ts","../../simulator/src/cpu/alu.ts","../../simulator/src/cpu/memory.ts","../../simulator/src/fs.ts","../../simulator/src/languages/grammars/asm.ohm.js","../../simulator/src/languages/asm.ts","../../simulator/src/languages/grammars/base.ohm.js","../../simulator/src/languages/base.ts","../../simulator/src/loader.ts","../../simulator/src/util/asm.ts","../../simulator/src/util/twos.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { assert, assertExists } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport { range } from \"@davidsouther/jiffies/lib/esm/range.js\";\nimport { bin } from \"../util/twos.js\";\nimport { Clock } from \"./clock.js\";\n\nexport const HIGH = 1;\nexport const LOW = 0;\nexport type Voltage = typeof HIGH | typeof LOW;\n\nexport interface Pin {\n  readonly name: string;\n  readonly width: number;\n  busVoltage: number;\n  pull(voltage: Voltage, bit?: number): void;\n  toggle(bit?: number): void;\n  voltage(bit?: number): Voltage;\n  connect(pin: Pin): void;\n}\n\nexport class Bus implements Pin {\n  state: Voltage[];\n  next: Pin[] = [];\n\n  constructor(readonly name: string, readonly width = 1) {\n    this.state = range(0, this.width).map(() => LOW);\n  }\n\n  ensureWidth(newWidth: number) {\n    assert(newWidth <= 16, `Cannot widen past 16 to ${newWidth} bits`);\n    if (this.width < newWidth) {\n      (this as { width: number }).width = newWidth;\n      this.state = [\n        ...this.state,\n        ...range(this.width, newWidth).map(() => LOW as Voltage),\n      ];\n    }\n  }\n\n  connect(next: Pin) {\n    this.next.push(next);\n    next.busVoltage = this.busVoltage;\n  }\n\n  pull(voltage: Voltage, bit = 0) {\n    assert(\n      bit >= 0 && bit < this.width,\n      `Bit out of bounds: ${this.name}@${bit}`\n    );\n    this.state[bit] = voltage;\n    this.next.forEach((n) => n.pull(voltage, bit));\n  }\n\n  voltage(bit = 0): Voltage {\n    assert(bit >= 0 && bit < this.width);\n    return this.state[bit];\n  }\n\n  set busVoltage(voltage: number) {\n    for (const i of range(0, this.width)) {\n      this.state[i] = ((voltage & (1 << i)) >> i) as Voltage;\n    }\n    this.next.forEach((n) => (n.busVoltage = this.busVoltage));\n  }\n\n  get busVoltage(): number {\n    return range(0, this.width).reduce((b, i) => b | (this.state[i] << i), 0);\n  }\n\n  toggle(bit = 0) {\n    const nextVoltage = this.voltage(bit) === LOW ? HIGH : LOW;\n    this.pull(nextVoltage, bit);\n  }\n}\n\nexport class InSubBus extends Bus {\n  constructor(\n    private bus: Pin,\n    private start: number,\n    override readonly width = 1\n  ) {\n    super(bus.name);\n    assert(\n      start >= 0 && start + width <= bus.width,\n      `Mismatched InSubBus dimensions on ${bus.name} (${width} + ${start} > ${bus.width})`\n    );\n    this.connect(bus);\n  }\n\n  override pull(voltage: Voltage, bit = 0) {\n    assert(bit >= 0 && bit < this.width);\n    this.bus.pull(voltage, this.start + bit);\n  }\n\n  override voltage(bit = 0): Voltage {\n    assert(bit >= 0 && bit < this.width);\n    return this.bus.voltage(this.start + bit);\n  }\n\n  override set busVoltage(voltage: number) {\n    const high = this.bus.busVoltage & ~mask(this.width + this.start);\n    const low = this.bus.busVoltage & mask(this.start);\n    const mid = (voltage & mask(this.width)) << this.start;\n    this.bus.busVoltage = high | mid | low;\n  }\n\n  override get busVoltage(): number {\n    return (this.bus.busVoltage >> this.start) & mask(this.width);\n  }\n\n  override connect(bus: Pin): void {\n    assert(\n      this.start + this.width <= bus.width,\n      `Mismatched InSubBus connection dimensions (From ${bus.name} to ${this.name})`\n    );\n    this.bus = bus;\n  }\n}\n\nexport class OutSubBus extends Bus {\n  constructor(\n    private bus: Pin,\n    private start: number,\n    override readonly width = 1\n  ) {\n    super(bus.name);\n    assert(start >= 0 && width <= bus.width, `Mismatched OutSubBus dimensions`);\n    this.connect(bus);\n  }\n\n  override set busVoltage(voltage: number) {\n    this.bus.busVoltage =\n      (voltage & mask(this.width + this.start)) >> this.start;\n  }\n\n  override get busVoltage(): number {\n    return this.bus.busVoltage & mask(this.width);\n  }\n\n  override connect(bus: Pin): void {\n    assert(\n      this.width <= bus.width,\n      `Mismatched OutSubBus connection dimensions`\n    );\n    this.bus = bus;\n  }\n}\n\nexport class ConstantBus extends Bus {\n  constructor(name: string, private readonly value: number) {\n    super(name, 16 /* TODO: get high bit index */);\n  }\n\n  pullHigh(_ = 0) {\n    return undefined;\n  }\n  pullLow(_ = 0) {\n    return undefined;\n  }\n  override voltage(_ = 0): Voltage {\n    return (this.busVoltage & 0x1) as Voltage;\n  }\n\n  override set busVoltage(voltage: number) {\n    // Noop\n  }\n  override get busVoltage(): number {\n    return this.value;\n  }\n}\n\nexport const TRUE_BUS = new ConstantBus(\"true\", 0xffff);\nexport const FALSE_BUS = new ConstantBus(\"false\", 0);\n\nexport function parsePinDecl(toPin: string): {\n  pin: string;\n  width: number;\n} {\n  const { pin, w } = toPin.match(/(?<pin>[a-zA-Z]+)(\\[(?<w>\\d+)\\])?/)\n    ?.groups as {\n    pin: string;\n    w?: string;\n  };\n  return {\n    pin,\n    width: w ? Number(w) : 1,\n  };\n}\n\nexport function parseToPin(toPin: string): {\n  pin: string;\n  start?: number;\n  end?: number;\n} {\n  const { pin, i, j } = toPin.match(\n    /(?<pin>[a-z]+)(\\[(?<i>\\d+)(\\.\\.(?<j>\\d+))?\\])?/\n  )?.groups as { pin: string; i?: string; j?: string };\n  return {\n    pin,\n    start: i ? Number(i) : undefined,\n    end: j ? Number(j) : undefined,\n  };\n}\n\nexport class Pins {\n  private readonly map = new Map<string, Pin>();\n\n  insert(pin: Pin) {\n    const { name } = pin;\n    assert(!this.map.has(name), `Pins already has ${name}!`);\n    this.map.set(name, pin);\n  }\n\n  emplace(name: string, minWidth?: number) {\n    if (this.has(name)) {\n      return this.get(name)!;\n    } else {\n      const pin = new Bus(name, minWidth);\n      this.insert(pin);\n      return pin;\n    }\n  }\n\n  has(pin: string): boolean {\n    return this.map.has(pin);\n  }\n\n  get(pin: string): Pin | undefined {\n    return this.map.get(pin);\n  }\n\n  entries(): Iterable<Pin> {\n    return this.map.values();\n  }\n\n  [Symbol.iterator]() {\n    return this.map[Symbol.iterator]();\n  }\n}\n\nlet id = 0;\nexport class Chip {\n  readonly id = id++;\n  ins = new Pins();\n  outs = new Pins();\n  pins = new Pins();\n  parts = new Set<Chip>();\n  clockedPins: Set<string>;\n\n  get clocked() {\n    if (this.clockedPins.size > 0) {\n      return true;\n    }\n    for (const part of this.parts) {\n      if (part.clocked) return true;\n    }\n    return false;\n  }\n\n  constructor(\n    ins: (string | { pin: string; width: number })[],\n    outs: (string | { pin: string; width: number })[],\n    public name?: string,\n    internals: (string | { pin: string; width: number })[] = [],\n    clocked: string[] = []\n  ) {\n    for (const inn of ins) {\n      const { pin, width = 1 } =\n        (inn as { pin: string }).pin !== undefined\n          ? (inn as { pin: string; width: number })\n          : parsePinDecl(inn as string);\n      this.ins.insert(new Bus(pin, width));\n    }\n\n    for (const out of outs) {\n      const { pin, width = 1 } =\n        (out as { pin: string }).pin !== undefined\n          ? (out as { pin: string; width: number })\n          : parsePinDecl(out as string);\n      this.outs.insert(new Bus(pin, width));\n    }\n\n    for (const internal of internals) {\n      const { pin, width = 1 } =\n        (internal as { pin: string }).pin !== undefined\n          ? (internal as { pin: string; width: number })\n          : parsePinDecl(internal as string);\n      this.pins.insert(new Bus(pin, width));\n    }\n\n    this.clockedPins = new Set(clocked);\n\n    Clock.get().$.subscribe(() => this.eval());\n  }\n\n  reset() {\n    for (const [_, pin] of this.ins) {\n      pin.busVoltage = 0;\n    }\n    for (const part of this.parts) {\n      part.reset();\n    }\n    this.eval();\n  }\n\n  in(pin = \"in\"): Pin {\n    assert(this.hasIn(pin), `No in pin ${pin}`);\n    return this.ins.get(pin)!;\n  }\n\n  out(pin = \"out\"): Pin {\n    assert(this.hasOut(pin), `No in pin ${pin}`);\n    return this.outs.get(pin)!;\n  }\n\n  hasIn(pin: string): boolean {\n    return this.ins.has(pin);\n  }\n\n  hasOut(pin: string): boolean {\n    return this.outs.has(pin);\n  }\n\n  pin(name: string): Pin {\n    assert(this.pins.has(name));\n    return this.pins.get(name)!;\n  }\n\n  get(name: string, offset?: number): Pin | undefined {\n    if (this.ins.has(name)) {\n      return this.ins.get(name)!;\n    }\n    if (this.outs.has(name)) {\n      return this.outs.get(name)!;\n    }\n    if (this.pins.has(name)) {\n      return this.pins.get(name)!;\n    }\n    return this.getBuiltin(name, offset);\n  }\n\n  private getBuiltin(name: string, offset = 0): Pin | undefined {\n    if (BUILTIN_NAMES.includes(name)) {\n      for (const part of this.parts) {\n        const pin = part.get(name, offset);\n        if (pin) {\n          return pin;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  isOutPin(pin: string): boolean {\n    return this.outs.has(pin);\n  }\n\n  wire(part: Chip, connections: Connection[]) {\n    this.parts.add(part);\n    for (const { to, from } of connections) {\n      if (part.isOutPin(to.name)) {\n        this.wireOutPin(part, to, from);\n      } else {\n        this.wireInPin(part, to, from);\n      }\n    }\n  }\n\n  private findPin(from: string, minWidth?: number): Pin {\n    if (from.toLowerCase() === \"true\" || from === \"1\") {\n      return TRUE_BUS;\n    }\n    if (from.toLowerCase() === \"false\" || from === \"0\") {\n      return FALSE_BUS;\n    }\n    if (this.ins.has(from)) {\n      return this.ins.get(from)!;\n    }\n    if (this.outs.has(from)) {\n      return this.outs.get(from)!;\n    }\n    return this.pins.emplace(from, minWidth);\n  }\n\n  private wireOutPin(part: Chip, to: PinSide, from: PinSide) {\n    const partPin = assertExists(\n      part.outs.get(to.name),\n      () => `Cannot wire to missing pin ${to.name}`\n    );\n    to.width ??= partPin.width;\n\n    let chipPin = this.findPin(from.name, from.width ?? to.width);\n    const isInternal = this.pins.has(chipPin.name);\n\n    from.width ??= chipPin.width;\n\n    if (chipPin instanceof ConstantBus) {\n      throw new Error(`Cannot wire to constant bus`);\n    }\n\n    // Widen internal pins\n    if (isInternal && chipPin instanceof Bus) {\n      chipPin.ensureWidth(from.start + from.width);\n    }\n\n    // Wrap the chipPin in an InBus when the chip side is dimensioned\n    if (from.start > 0 || from.width !== chipPin.width) {\n      chipPin = new InSubBus(chipPin, from.start, from.width);\n    }\n\n    // Wrap the chipPin in an OutBus when the part side is dimensioned\n    if (to.start > 0 || to.width !== chipPin.width) {\n      chipPin = new OutSubBus(chipPin, to.start, to.width);\n    }\n\n    partPin.connect(chipPin);\n  }\n\n  private wireInPin(part: Chip, to: PinSide, from: PinSide) {\n    let partPin = assertExists(\n      part.ins.get(to.name),\n      () => `Cannot wire to missing pin ${to.name}`\n    );\n    to.width ??= partPin.width;\n\n    const chipPin = this.findPin(from.name, from.width ?? to.width);\n\n    from.width ??= chipPin.width;\n\n    // Wrap the partPin in an InBus when the part side is dimensioned\n    if (to.start > 0 || to.width !== chipPin.width) {\n      partPin = new InSubBus(partPin, to.start, to.width);\n    }\n\n    // Wrap the partPin in an OutBus when the chip side is dimensioned\n    if (![\"true\", \"false\"].includes(chipPin.name)) {\n      if (from.start > 0 || from.width !== chipPin.width) {\n        partPin = new OutSubBus(partPin, from.start, from.width);\n      }\n    }\n    chipPin.connect(partPin);\n  }\n\n  eval() {\n    for (const chip of this.parts) {\n      // TODO topological sort\n      // eval chip input busses\n      TRUE_BUS.next.forEach((pin) => (pin.busVoltage = TRUE_BUS.busVoltage));\n      FALSE_BUS.next.forEach((pin) => (pin.busVoltage = FALSE_BUS.busVoltage));\n      chip.eval();\n      // eval output busses\n    }\n  }\n\n  tick() {\n    this.eval();\n  }\n\n  tock() {\n    this.eval();\n  }\n\n  remove() {\n    for (const part of this.parts) {\n      part.remove();\n    }\n  }\n\n  // For the ROM32K builtin to load from a file system\n  async load(fs: FileSystem, path: string): Promise<void> {\n    for (const part of this.parts) {\n      if (part.name === \"ROM32K\") {\n        await part.load(fs, path);\n      }\n    }\n  }\n}\n\nexport class Low extends Chip {\n  constructor() {\n    super([], []);\n    this.outs.insert(FALSE_BUS);\n  }\n}\n\nexport class High extends Chip {\n  constructor() {\n    super([], []);\n    this.outs.insert(TRUE_BUS);\n  }\n}\n\nexport class ClockedChip extends Chip {\n  override get clocked(): boolean {\n    return true;\n  }\n\n  #subscription = Clock.get().$.subscribe(({ level }) => {\n    if (level === LOW) {\n      this.tock();\n    } else {\n      this.tick();\n    }\n  });\n\n  override remove() {\n    this.#subscription.unsubscribe();\n    super.remove();\n  }\n\n  override reset(): void {\n    super.reset();\n    this.tick();\n    this.tock();\n  }\n}\n\nexport interface PinSide {\n  name: string;\n  start: number;\n  width?: number;\n}\n\nexport interface Connection {\n  // To is the part side\n  to: PinSide;\n  // From is the chip side\n  from: PinSide;\n}\n\nexport type Pinout = Record<string, string>;\nexport interface SerializedChip {\n  id: number;\n  name: string;\n  ins: Pinout;\n  outs: Pinout;\n  pins: Pinout;\n  children: SerializedChip[];\n}\n\nfunction mask(width: number) {\n  return Math.pow(2, width) - 1;\n}\n\nfunction setBus(busses: Pinout, pin: Pin) {\n  busses[pin.name] = bin(\n    (pin.busVoltage & mask(pin.width)) <<\n      (pin as unknown as { start: number }).start ?? 0\n  );\n  return busses;\n}\n\nexport function printChip(chip: Chip): SerializedChip {\n  return {\n    id: chip.id,\n    name: chip.name ?? chip.constructor.name,\n    ins: [...chip.ins.entries()].reduce(setBus, {} as Pinout),\n    outs: [...chip.outs.entries()].reduce(setBus, {} as Pinout),\n    pins: [...chip.pins.entries()].reduce(setBus, {} as Pinout),\n    children: [...chip.parts.values()].map(printChip),\n  };\n}\n\nexport const BUILTIN_NAMES = [\n  \"Register\",\n  \"ARegister\",\n  \"DRegister\",\n  \"PC\",\n  \"RAM8\",\n  \"RAM64\",\n  \"RAM512\",\n  \"RAM4K\",\n  \"RAM16K\",\n  \"ROM32K\",\n  \"Screen\",\n  \"Keyboard\",\n  \"Memory\",\n];\n","import { BehaviorSubject, Observable, Subject } from \"rxjs\";\nimport { assert } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { HIGH, LOW, Voltage } from \"./chip.js\";\n\ninterface Tick {\n  readonly level: Voltage;\n  readonly ticks: number;\n}\n\nlet clock: Clock;\nexport class Clock {\n  private level: Voltage = LOW;\n  private ticks = 0;\n\n  static get() {\n    if (clock === undefined) {\n      clock = new Clock();\n    }\n    return clock;\n  }\n\n  get isHigh(): boolean {\n    return this.level === HIGH;\n  }\n\n  get isLow(): boolean {\n    return this.level === LOW;\n  }\n\n  private subject = new BehaviorSubject<Tick>({\n    level: this.level,\n    ticks: this.ticks,\n  });\n  readonly frameSubject = new Subject<void>();\n  readonly resetSubject = new Subject<void>();\n\n  readonly $: Observable<Tick> = this.subject;\n  readonly frame$: Observable<void> = this.frameSubject;\n  readonly reset$: Observable<void> = this.resetSubject;\n\n  private next() {\n    this.subject.next({\n      level: this.level,\n      ticks: this.ticks,\n    });\n  }\n\n  private constructor() {\n    // private\n  }\n\n  reset() {\n    this.level = LOW;\n    this.ticks = 0;\n    this.next();\n    this.resetSubject.next();\n  }\n\n  tick() {\n    assert(this.level === LOW, \"Can only tick up from LOW\");\n    this.level = HIGH;\n    this.next();\n  }\n\n  tock() {\n    assert(this.level === HIGH, \"Can only tock down from HIGH\");\n    this.level = LOW;\n    this.ticks += 1;\n    this.next();\n  }\n\n  toggle() {\n    this.level === HIGH ? this.tock() : this.tick();\n  }\n\n  eval() {\n    this.tick();\n    this.tock();\n  }\n\n  frame() {\n    this.frameSubject.next();\n  }\n\n  toString() {\n    return `${this.ticks}${this.level === HIGH ? \"+\" : \"\"}`;\n  }\n}\n","export type COMMANDS_ASM =\n  | \"0\"\n  | \"1\"\n  | \"-1\"\n  | \"D\"\n  | \"A\"\n  | \"M\"\n  | \"!D\"\n  | \"!A\"\n  | \"-D\"\n  | \"-A\"\n  | \"D+1\"\n  | \"A+1\"\n  | \"D-1\"\n  | \"A-1\"\n  | \"D+A\"\n  | \"D-A\"\n  | \"D-M\"\n  | \"A-D\"\n  | \"D&A\"\n  | \"D&M\"\n  | \"D|A\"\n  | \"D|M\";\n\nexport type COMMANDS_OP =\n  | 0b101010\n  | 0b111111\n  | 0b111010\n  | 0b001100\n  | 0b110000\n  | 0b110000\n  | 0b001101\n  | 0b110001\n  | 0b001111\n  | 0b110011\n  | 0b011111\n  | 0b110111\n  | 0b001110\n  | 0b110010\n  | 0b000010\n  | 0b010011\n  | 0b010011\n  | 0b000111\n  | 0b000000\n  | 0b000000\n  | 0b010101\n  | 0b010101;\n\n//Usefull for the visualization of the ALU\nexport type COMMANDS_ALU =\n  | \"0\"\n  | \"1\"\n  | \"-1\"\n  | \"x\"\n  | \"y\"\n  | \"!x\"\n  | \"!y\"\n  | \"-x\"\n  | \"-y\"\n  | \"x+1\"\n  | \"y+1\"\n  | \"x-1\"\n  | \"y-1\"\n  | \"x+y\"\n  | \"x-y\"\n  | \"y-x\"\n  | \"x&y\"\n  | \"x|y\";\n\nexport const COMMANDS_ALU: {\n  op: Record<COMMANDS_OP, COMMANDS_ALU>;\n} = {\n  op: {\n    0x2a: \"0\",\n    0x3f: \"1\",\n    0x3a: \"-1\",\n    0x0c: \"x\",\n    0x30: \"y\",\n    0x0d: \"!x\",\n    0x31: \"!y\",\n    0x0f: \"-x\",\n    0x33: \"-y\",\n    0x1f: \"x+1\",\n    0x37: \"y+1\",\n    0x0e: \"x-1\",\n    0x32: \"y-1\",\n    0x02: \"x+y\",\n    0x13: \"x-y\",\n    0x07: \"y-x\",\n    0x00: \"x&y\",\n    0x15: \"x|y\",\n  },\n};\n\nexport const COMMANDS: {\n  asm: Record<COMMANDS_ASM, COMMANDS_OP>;\n  op: Record<COMMANDS_OP, COMMANDS_ASM>;\n} = {\n  asm: {\n    \"0\": 0b101010, // 42 0x2A\n    \"1\": 0b111111, // 63 0x3F\n    \"-1\": 0b111010, // 58 0x3A\n    D: 0b001100, // 12 0x0C\n    A: 0b110000, // 48 0x30\n    M: 0b110000, // 48 0x30\n    \"!D\": 0b001101, // 13 0x0D\n    \"!A\": 0b110001, // 49 0x31\n    \"-D\": 0b001111, // 15 0x0F\n    \"-A\": 0b110011, // 51 0x33\n    \"D+1\": 0b011111, // 31 0x1F\n    \"A+1\": 0b110111, // 55 0x37\n    \"D-1\": 0b001110, // 14 0x0E\n    \"A-1\": 0b110010, // 50 0x32\n    \"D+A\": 0b000010, //  2 0x02\n    \"D-A\": 0b010011, // 19 0x13\n    \"D-M\": 0b010011, // 19 0x13\n    \"A-D\": 0b000111, //  7 0x07\n    \"D&A\": 0b000000, //  0 0x00\n    \"D&M\": 0b000000, //  0 0x00\n    \"D|A\": 0b010101, // 21 0x15\n    \"D|M\": 0b010101, // 21 0x15\n  },\n  op: {\n    0x2a: \"0\",\n    0x3f: \"1\",\n    0x3a: \"-1\",\n    0x0c: \"D\",\n    0x30: \"A\",\n    0x0d: \"!D\",\n    0x31: \"!A\",\n    0x0f: \"-D\",\n    0x33: \"-A\",\n    0x1f: \"D+1\",\n    0x37: \"A+1\",\n    0x0e: \"D-1\",\n    0x32: \"A-1\",\n    0x02: \"D+A\",\n    0x13: \"D-A\",\n    0x07: \"A-D\",\n    0x00: \"D&A\",\n    0x15: \"D|A\",\n  },\n};\n\nexport type ASSIGN_ASM = \"\" | \"M\" | \"D\" | \"MD\" | \"A\" | \"AM\" | \"AD\" | \"AMD\";\nexport type ASSIGN_OP = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\n\nexport const ASSIGN: {\n  asm: Record<ASSIGN_ASM, ASSIGN_OP>;\n  op: Record<ASSIGN_OP, ASSIGN_ASM>;\n} = {\n  asm: {\n    \"\": 0x0,\n    M: 0b001,\n    D: 0b010,\n    MD: 0b011,\n    A: 0b100,\n    AM: 0b101,\n    AD: 0b110,\n    AMD: 0b111,\n  },\n  op: {\n    0x0: \"\",\n    0x1: \"M\",\n    0x2: \"D\",\n    0x3: \"MD\",\n    0x4: \"A\",\n    0x5: \"AM\",\n    0x6: \"AD\",\n    0x7: \"AMD\",\n  },\n};\n\nexport type JUMP_ASM =\n  | \"\"\n  | \"JGT\"\n  | \"JEQ\"\n  | \"JGE\"\n  | \"JLT\"\n  | \"JNE\"\n  | \"JLE\"\n  | \"JMP\";\nexport type JUMP_OP = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\nexport const JUMP: {\n  asm: Record<JUMP_ASM, JUMP_OP>;\n  op: Record<JUMP_OP, JUMP_ASM>;\n} = {\n  asm: {\n    \"\": 0b0,\n    JGT: 0b001,\n    JEQ: 0b010,\n    JGE: 0b011,\n    JLT: 0b100,\n    JNE: 0b101,\n    JLE: 0b110,\n    JMP: 0b111,\n  },\n  op: {\n    0x0: \"\",\n    0x1: \"JGT\",\n    0x2: \"JEQ\",\n    0x3: \"JGE\",\n    0x4: \"JLT\",\n    0x5: \"JNE\",\n    0x6: \"JLE\",\n    0x7: \"JMP\",\n  },\n};\n\nexport const Flags = {\n  0x01: \"Positive\",\n  0x00: \"Zero\",\n  0x0f: \"Negative\",\n  Positive: 0x01,\n  Zero: 0x00,\n  Negative: 0x0f,\n};\n\nexport function alu(op: number, d: number, a: number): [number, number] {\n  let o = 0;\n  switch (op) {\n    case 0x2a:\n      o = 0;\n      break;\n    case 0x3f:\n      o = 1;\n      break;\n    case 0x3a:\n      o = -1;\n      break;\n    case 0x0c:\n      o = d;\n      break;\n    case 0x30:\n      o = a;\n      break;\n    case 0x0d:\n      o = ~d;\n      break;\n    case 0x31:\n      o = ~a;\n      break;\n    case 0x0f:\n      o = -d;\n      break;\n    case 0x33:\n      o = -a;\n      break;\n    case 0x1f:\n      o = d + 1;\n      break;\n    case 0x37:\n      o = a + 1;\n      break;\n    case 0x0e:\n      o = d - 1;\n      break;\n    case 0x32:\n      o = a - 1;\n      break;\n    case 0x02:\n      o = d + a;\n      break;\n    case 0x13:\n      o = d - a;\n      break;\n    case 0x07:\n      o = a - d;\n      break;\n    case 0x00:\n      o = d & a;\n      break;\n    case 0x15:\n      o = d | a;\n      break;\n  }\n\n  o = o & 0xffff;\n  const flags =\n    o === 0 ? Flags.Zero : o & 0x8000 ? Flags.Negative : Flags.Positive;\n  return [o, flags];\n}\n\nexport function alua(op: number, d: number, a: number): [number, number] {\n  if (op & 0b100000) d = 0;\n  if (op & 0b010000) d = ~d & 0xffff;\n  if (op & 0b001000) a = 0;\n  if (op & 0b000100) a = ~a & 0xffff;\n\n  let o = (op & 0b000010 ? d + a : d & a) & 0xffff;\n  if (op & 0b000001) o = ~o & 0xffff;\n\n  const flags =\n    o === 0 ? Flags.Zero : o & 0x8000 ? Flags.Negative : Flags.Positive;\n  return [o, flags];\n}\n","import { assert } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport { op } from \"../util/asm.js\";\nimport { int10, int16, int2 } from \"../util/twos.js\";\nimport { load } from \"../fs.js\";\n\nexport const FORMATS = [\"bin\", \"dec\", \"hex\", \"asm\"];\nexport type Format = typeof FORMATS[number];\n\nexport const SCREEN_OFFSET = 0x4000;\nexport const SCREEN_ROWS = 512;\nexport const SCREEN_COLS = 256;\nexport const SCREEN_SIZE = SCREEN_ROWS * SCREEN_COLS;\nexport const KEYBOARD_OFFSET = 0x6000;\n\nexport interface MemoryAdapter {\n  size: number;\n  get(index: number): number;\n  set(index: number, value: number): void;\n  reset(): void;\n  update(cell: number, value: string, format: Format): void;\n  load(fs: FileSystem, path: string): Promise<void>;\n  loadBytes(bytes: number[]): void;\n  range(start?: number, end?: number): number[];\n  map<T>(\n    fn: (index: number, value: number) => T,\n    start?: number,\n    end?: number\n  ): Iterable<T>;\n}\n\nexport interface KeyboardAdapter {\n  getKey(): number;\n  setKey(key: number): void;\n  clearKey(): void;\n}\n\nexport class Memory implements MemoryAdapter {\n  private memory: Int16Array;\n\n  get size(): number {\n    return this.memory.length;\n  }\n\n  constructor(memory: ArrayBuffer | number) {\n    if (typeof memory === \"number\") {\n      this.memory = new Int16Array(memory);\n    } else {\n      this.memory = new Int16Array(memory);\n    }\n  }\n\n  get(index: number): number {\n    if (index < 0 || index >= this.size) {\n      return 0xffff;\n    }\n    return this.memory[index] ?? 0;\n  }\n\n  set(index: number, value: number): void {\n    if (index >= 0 && index < this.size) {\n      this.memory[index] = value & 0xffff;\n    }\n  }\n\n  reset(): void {\n    this.memory.fill(0);\n  }\n\n  update(cell: number, value: string, format: Format) {\n    let current: number;\n    switch (format) {\n      case \"asm\":\n        current = op(value);\n        break;\n      case \"bin\":\n        current = int2(value);\n        break;\n      case \"hex\":\n        current = int16(value);\n        break;\n      case \"dec\":\n      default:\n        current = int10(value);\n        break;\n    }\n\n    if (isFinite(current) && current <= 0xffff) {\n      this.set(cell, current);\n    }\n  }\n\n  async load(fs: FileSystem, path: string) {\n    try {\n      this.loadBytes(await load(fs, path));\n    } catch (cause) {\n      // throw new Error(`ROM32K Failed to load file ${path}`, { cause });\n      throw new Error(`Memory Failed to load file ${path}`);\n    }\n  }\n\n  loadBytes(bytes: number[]): void {\n    this.memory.set(new Int16Array(bytes));\n    this.memory.fill(0, bytes.length, this.size);\n  }\n\n  range(start = 0, end = this.size): number[] {\n    return [...this.memory.slice(start, end)];\n  }\n\n  *map<T>(\n    fn: (index: number, value: number) => T,\n    start = 0,\n    end = this.size\n  ): Iterable<T> {\n    assert(start < end);\n    for (let i = start; i < end; i++) {\n      yield fn(i, this.get(i));\n    }\n  }\n}\n\nexport class SubMemory implements MemoryAdapter {\n  constructor(\n    private readonly parent: MemoryAdapter,\n    readonly size: number,\n    private readonly offset: number\n  ) {}\n\n  get(index: number): number {\n    if (index < 0 || index >= this.size) {\n      return 0xffff;\n    }\n    return this.parent.get(this.offset + index);\n  }\n\n  set(index: number, value: number): void {\n    if (index >= 0 && index < this.size) {\n      this.parent.set(index + this.offset, value);\n    }\n  }\n\n  reset(): void {\n    for (let i = 0; i < this.size; i++) {\n      this.set(i, 0);\n    }\n  }\n\n  update(index: number, value: string, format: string): void {\n    if (index >= 0 && index < this.size) {\n      this.parent.update(index + this.offset, value, format);\n    }\n  }\n\n  load(fs: FileSystem, path: string): Promise<void> {\n    return this.parent.load(fs, path);\n  }\n\n  loadBytes(bytes: number[]): void {\n    return this.parent.loadBytes(bytes);\n  }\n\n  range(start?: number, end?: number): number[] {\n    return this.parent.range(start, end);\n  }\n  map<T>(\n    fn: (index: number, value: number) => T,\n    start?: number,\n    end?: number\n  ): Iterable<T> {\n    return this.parent.map(fn, start, end);\n  }\n}\n\nexport class MemoryKeyboard extends SubMemory implements KeyboardAdapter {\n  constructor(memory: MemoryAdapter) {\n    super(memory, 1, 0x6000);\n  }\n\n  getKey(): number {\n    return this.get(0);\n  }\n\n  setKey(key: number): void {\n    this.set(0, key & 0xffff);\n  }\n\n  clearKey(): void {\n    this.set(0, 0);\n  }\n}\n\nexport class ROM extends Memory {\n  static readonly SIZE = 0x8000;\n  constructor(program: Int16Array) {\n    const arr = new Int16Array(ROM.SIZE);\n    arr.set(program);\n    super(arr);\n  }\n}\n\nexport class RAM extends Memory {\n  // 4k main memory, 2k screen memory, 1 keyboard\n  // static readonly SIZE = 0x4000 + 0x2000 + 0x0001;\n  static readonly SIZE = 0x8000;\n  constructor() {\n    super(RAM.SIZE);\n  }\n}\n","import { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport * as loader from \"./loader.js\";\n\nexport async function load(fs: FileSystem, path: string): Promise<number[]> {\n  if (path.endsWith(\".hack\")) {\n    return loadHack(fs, path);\n  }\n\n  if (path.endsWith(\".asm\")) {\n    return loadAsm(fs, path);\n  }\n\n  throw new Error(`Cannot load file without hack or asm extension ${path}`);\n}\n\nexport async function loadAsm(fs: FileSystem, path: string): Promise<number[]> {\n  return loader.loadAsm(await fs.readFile(path));\n}\n\nexport async function loadHack(\n  fs: FileSystem,\n  path: string\n): Promise<number[]> {\n  return loader.loadHack(await fs.readFile(path));\n}\n","const asm = `\nASM <: Base {\n  Root := ASM\n  ASM = Instruction*\n  \n  Instruction = Label|AInstruction|CInstruction\n  \n  Label = OpenParen identifier closeParen\n  AInstruction = at (identifier | decNumber)\n  CInstruction = assign? op jmp?\n  \n  assign = (\n      \"AMD\"\n      | \"AM\"\n      | \"AD\"\n      | \"MD\"\n      | \"M\"\n      | \"D\"\n      | \"A\"\n      ) equal\n      \n  op =\n      | \"0\" | \"1\" | \"-1\"\n      | \"!D\" | \"!A\" | \"!M\"\n      | \"-D\" | \"-A\" | \"-M\"\n      | \"D+1\" | \"A+1\" | \"M+1\"\n      | \"D-1\" | \"A-1\" | \"M-1\"\n      | \"D+A\" | \"D+M\"\n      | \"D-A\" | \"D-M\"\n      | \"A-D\" | \"M-D\"\n      | \"D&A\" | \"D&M\"\n      | \"D|A\" | \"D|M\"\n      | \"D\" | \"A\" | \"M\"\n\n\n  jmp = semi (\"JGT\" | \"JEQ\" | \"JGE\" | \"JLT\" | \"JNE\" | \"JLE\" | \"JMP\")\n}`;\nexport default asm;\n","import { assertExists } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport ohm from \"ohm-js\";\nimport {\n  ASSIGN,\n  ASSIGN_ASM,\n  ASSIGN_OP,\n  COMMANDS,\n  COMMANDS_ASM,\n  COMMANDS_OP,\n  JUMP,\n  JUMP_ASM,\n  JUMP_OP,\n} from \"../cpu/alu.js\";\nimport { KEYBOARD_OFFSET, SCREEN_OFFSET } from \"../cpu/memory.js\";\nimport { makeC } from \"../util/asm.js\";\nimport { Span, baseSemantics, grammars, makeParser } from \"./base.js\";\n\nimport asmGrammar from \"./grammars/asm.ohm.js\";\n\nexport const grammar = ohm.grammar(asmGrammar, grammars);\nexport const asmSemantics = grammar.extendSemantics(baseSemantics);\n\nexport interface Asm {\n  instructions: AsmInstruction[];\n}\n\nexport type AsmInstruction =\n  | AsmAInstruction\n  | AsmCInstruction\n  | AsmLabelInstruction;\n\nexport type AsmAInstruction = AsmALabelInstruction | AsmAValueInstruction;\nexport interface AsmALabelInstruction {\n  type: \"A\";\n  label: string;\n  span: Span;\n  lineNum: number;\n}\n\nexport interface AsmAValueInstruction {\n  type: \"A\";\n  value: number;\n  span: Span;\n  lineNum: number;\n}\n\nexport function isAValueInstruction(\n  inst: AsmAInstruction\n): inst is AsmAValueInstruction {\n  return (inst as AsmAValueInstruction).value !== undefined;\n}\n\nfunction isALabelInstruction(\n  inst: AsmAInstruction\n): inst is AsmALabelInstruction {\n  return (inst as AsmALabelInstruction).label !== undefined;\n}\n\nexport interface AsmCInstruction {\n  type: \"C\";\n  op: COMMANDS_OP;\n  isM: boolean;\n  store?: ASSIGN_OP;\n  jump?: JUMP_OP;\n  span: Span;\n  lineNum: number;\n}\n\nexport interface AsmLabelInstruction {\n  type: \"L\";\n  label: string;\n  lineNum: number;\n}\n\nasmSemantics.addAttribute<Asm>(\"root\", {\n  Root(_) {\n    return this.asm;\n  },\n});\n\nasmSemantics.addAttribute<Asm>(\"asm\", {\n  Root(asm) {\n    return {\n      instructions: asm\n        .child(0)\n        .children.map(({ instruction }) => instruction as AsmInstruction),\n    };\n  },\n});\n\nasmSemantics.addAttribute<AsmInstruction>(\"instruction\", {\n  AInstruction(_at, val): AsmAInstruction {\n    try {\n      return {\n        type: \"A\",\n        label: val.name,\n        span: {\n          start: _at.source.startIdx,\n          end: val.source.endIdx,\n        },\n        lineNum: _at.source.getLineAndColumn().lineNum,\n      };\n    } catch (e) {\n      // Pass\n    }\n\n    try {\n      return {\n        type: \"A\",\n        value: val.value,\n        span: {\n          start: _at.source.startIdx,\n          end: val.source.endIdx,\n        },\n        lineNum: _at.source.getLineAndColumn().lineNum,\n      };\n    } catch (e) {\n      // pass\n    }\n\n    throw new Error(`AsmAInstruction must have either a name or a value`);\n  },\n  CInstruction(assignN, opN, jmpN): AsmCInstruction {\n    const assign = assignN.child(0)?.child(0)?.sourceString as ASSIGN_ASM;\n    const op = opN.sourceString.replace(\"M\", \"A\") as COMMANDS_ASM;\n    const jmp = jmpN.child(0)?.child(1)?.sourceString as JUMP_ASM;\n    const isM = opN.sourceString.includes(\"M\");\n    const inst: AsmCInstruction = {\n      type: \"C\",\n      op: COMMANDS.asm[op],\n      isM,\n      span: {\n        start: assignN.source.startIdx,\n        end: jmpN.source.endIdx,\n      },\n      lineNum: assignN.source.getLineAndColumn().lineNum,\n    };\n    if (jmp) inst.jump = JUMP.asm[jmp];\n    if (assign) inst.store = ASSIGN.asm[assign];\n    return inst;\n  },\n  Label(_o, { name }, _c): AsmLabelInstruction {\n    return {\n      type: \"L\",\n      label: name,\n      lineNum: _o.source.getLineAndColumn().lineNum,\n    };\n  },\n});\n\nexport function fillLabel(\n  asm: Asm,\n  symbolCallback?: (name: string, value: number, isVar: boolean) => void\n) {\n  let nextLabel = 16;\n  const symbols = new Map<string, number>([\n    [\"R0\", 0],\n    [\"R1\", 1],\n    [\"R2\", 2],\n    [\"R3\", 3],\n    [\"R4\", 4],\n    [\"R5\", 5],\n    [\"R6\", 6],\n    [\"R7\", 7],\n    [\"R8\", 8],\n    [\"R9\", 9],\n    [\"R10\", 10],\n    [\"R11\", 11],\n    [\"R12\", 12],\n    [\"R13\", 13],\n    [\"R14\", 14],\n    [\"R15\", 15],\n    [\"SP\", 0],\n    [\"LCL\", 1],\n    [\"ARG\", 2],\n    [\"THIS\", 3],\n    [\"THAT\", 4],\n    [\"SCREEN\", SCREEN_OFFSET],\n    [\"KBD\", KEYBOARD_OFFSET],\n  ]);\n\n  function getLabelValue(label: string) {\n    if (!symbols.has(label)) {\n      symbols.set(label, nextLabel);\n      symbolCallback?.(label, nextLabel, true);\n      nextLabel += 1;\n    }\n    return assertExists(symbols.get(label), `Label not in symbols: ${label}`);\n  }\n\n  function transmuteAInstruction(instruction: AsmALabelInstruction) {\n    const value = getLabelValue(instruction.label);\n    (instruction as unknown as AsmAValueInstruction).value = value;\n    delete (instruction as unknown as { label: undefined }).label;\n  }\n\n  const unfilled: AsmALabelInstruction[] = [];\n  let line = 0;\n  for (const instruction of asm.instructions) {\n    if (instruction.type === \"L\") {\n      if (symbols.has(instruction.label)) {\n        throw new Error(`ASM Duplicate label ${instruction.label}`);\n      } else {\n        symbols.set(instruction.label, line);\n        symbolCallback?.(instruction.label, line, false);\n      }\n      continue;\n    }\n\n    line += 1;\n\n    if (instruction.type === \"A\") {\n      if (isALabelInstruction(instruction)) {\n        unfilled.push(instruction);\n      }\n    }\n  }\n\n  unfilled.forEach(transmuteAInstruction);\n}\n\nexport function translateInstruction(inst: AsmInstruction) {\n  if (inst.type === \"A\") {\n    if (isALabelInstruction(inst)) {\n      throw new Error(`ASM Emitting unfilled A instruction`);\n    }\n    return inst.value;\n  }\n  if (inst.type === \"C\") {\n    return makeC(inst.isM, inst.op, inst.store, inst.jump);\n  }\n  return undefined;\n}\n\nexport function emit(asm: Asm): number[] {\n  return asm.instructions\n    .map(translateInstruction)\n    .filter((op): op is number => op !== undefined);\n}\n\nexport const ASM = {\n  grammar: asmGrammar,\n  semantics: asmSemantics,\n  parser: grammar,\n  parse: makeParser<Asm>(grammar, asmSemantics),\n  passes: {\n    fillLabel,\n    emit,\n  },\n};\n","const base = `\nBase {\n  Root = Value*\n\n  At = at\n  Bang = bang\n  Bar = bar\n  CloseAngle = closeAngle\n  CloseBrace = closeBrace\n  CloseParen = closeParen\n  CloseSquare = closeSquare\n  Comma = comma\n  Dollar = dollar\n  Dot = dot\n  DoubleQuote = doubleQuote\n  Equal = equal\n  OpenAngle = openAngle\n  OpenBrace = openBrace\n  OpenParen = openParen\n  OpenSquare = openSquare\n  Percent = percent\n  Semi = semi\n  Underscore = underscore\n\n  at = \"@\"\n  bang = \"!\"\n  bar = \"|\"\n  closeAngle = \">\"\n  closeBrace = \"}\"\n  closeParen = \")\"\n  closeSquare = \"]\"\n  comma = \",\"\n  dollar = \"$\"\n  dot = \".\"\n  doubleQuote = \"\\\\\"\"\n  equal = \"=\"\n  minus = \"-\"\n  newline = \"\\\\r\"? \"\\\\n\"\n  openAngle = \"<\"\n  openBrace = \"{\"\n  openParen = \"(\"\n  openSquare = \"[\"\n  percent = \"%\"\n  semi = \";\"\n  underscore = \"_\"\n\n  Value = identifier | number | boolean\n\n  boolean = true | false\n  True = true\n  False = false\n  true = \"true\"\n  false = \"false\"\n\n  Name = identifier\n  identifier = (letter|underscore) (alnum|underscore|dot|dollar)*\n\n  Number = number\n  number = hexNumber | decNumber | binNumber\n  binNumber = (\"%B\") (\"0\"|\"1\")+\n  hexNumber = (\"%X\") hexDigit+\n  decNumber = (\"%D\")? (wholeDec | realDec)\n  wholeDec = minus? digit+\n  realDec = minus? digit* \".\" digit+\n\n  String = DoubleQuote (~doubleQuote any)* doubleQuote\n  \n  spaces := (lineComment | comment | space)*\n  commentStart = \"/*\"\n  commentEnd = \"*/\"\n  comment = commentStart (~commentEnd any)* commentEnd\n  lineCommentStart = \"//\"\n  lineComment = lineCommentStart (~\"\\\\n\" any)* \"\\\\n\"\n\n  List<elem, sep> = NonemptyListOf<elem, sep> sep?\n  EmptyList<elem, sep> = EmptyList<elem, sep> sep?\n}`;\nexport default base;\n","import ohm from \"ohm-js\";\nimport { int10, int16, int2 } from \"../util/twos.js\";\nimport { Err, Ok, Result } from \"@davidsouther/jiffies/lib/esm/result.js\";\n\nexport const UNKNOWN_PARSE_ERROR = `Unknown parse error`;\n\nimport baseGrammar from \"./grammars/base.ohm.js\";\nexport const grammars = {\n  Base: ohm.grammar(baseGrammar),\n};\n\nexport const baseSemantics = grammars.Base.createSemantics();\n\nbaseSemantics.extendOperation(\"asIteration\", {\n  List(list, _) {\n    return list.asIteration();\n  },\n});\n\nbaseSemantics.addAttribute(\"value\", {\n  decNumber(_, digits): number {\n    return int10(digits.sourceString);\n  },\n  wholeDec(_, digits): number {\n    return int10(digits.sourceString);\n  },\n  binNumber(_, digits) {\n    return int2(digits.sourceString);\n  },\n  hexNumber(_, digits) {\n    return int16(digits.sourceString);\n  },\n  Number(num) {\n    return num.value;\n  },\n  Name(ident) {\n    return ident.name;\n  },\n  identifier(_, __): string {\n    return this.sourceString;\n  },\n});\n\nbaseSemantics.addAttribute(\"name\", {\n  identifier(_, __): string {\n    return this.sourceString;\n  },\n  Name(_): string {\n    return this.child(0)?.name;\n  },\n});\n\nbaseSemantics.addAttribute(\"String\", {\n  String(_a, str, _b) {\n    return str.sourceString;\n  },\n});\n\nexport type ParseError = Error | { message: string; shortMessage: string };\n\nexport function makeParser<ResultType>(\n  grammar: ohm.Grammar,\n  semantics: ohm.Semantics,\n  property: (obj: ohm.Dict) => ResultType = ({ root }) => root\n): (source: string) => Result<ResultType, ParseError> {\n  return function parse(source) {\n    try {\n      const match = grammar.match(source);\n      if (match.succeeded()) {\n        const parsed = semantics(match);\n        const parse = property(parsed);\n        return Ok(parse);\n      } else {\n        return Err({\n          message: match.message ?? UNKNOWN_PARSE_ERROR,\n          shortMessage: match.shortMessage ?? UNKNOWN_PARSE_ERROR,\n        });\n      }\n    } catch (e) {\n      return Err(e as Error);\n    }\n  };\n}\n\nexport interface Span {\n  start: number;\n  end: number;\n}\n","import { unwrap } from \"@davidsouther/jiffies/lib/esm/result.js\";\nimport { ASM } from \"./languages/asm.js\";\nimport { int2, parseTwosInt } from \"./util/twos.js\";\n\nexport async function loadAsm(source: string): Promise<number[]> {\n  const asm = unwrap(ASM.parse(source));\n  ASM.passes.fillLabel(asm);\n  return ASM.passes.emit(asm);\n}\n\nexport async function loadHack(source: string): Promise<number[]> {\n  return source\n    .split(\"\\n\")\n    .filter((line) => line.trim() !== \"\")\n    .map(int2);\n}\n\nexport function loadHackSync(source: string): number[] {\n  return source\n    .split(\"\\n\")\n    .filter((line) => line.trim() !== \"\")\n    .map(int2);\n}\n\nexport async function loadBlob(bytes: string): Promise<number[]> {\n  return bytes\n    .split(\"\\n\")\n    .filter((line) => line.trim() !== \"\")\n    .map(parseTwosInt);\n}\n","import {\n  ASSIGN,\n  ASSIGN_ASM,\n  ASSIGN_OP,\n  COMMANDS,\n  COMMANDS_ASM,\n  COMMANDS_OP,\n  JUMP,\n  JUMP_ASM,\n  JUMP_OP,\n} from \"../cpu/alu.js\";\n\nexport type CommandOps = keyof typeof COMMANDS.op;\nexport type JumpOps = keyof typeof JUMP.op;\nexport type StoreOps = keyof typeof ASSIGN.op;\n\nexport function asm(op: number): string {\n  if (op & 0x8000) {\n    return cInstruction(op);\n  }\n  return aInstruction(op);\n}\n\nfunction cInstruction(op: number): string {\n  op = op & 0xffff; // Clear high order bits\n  const mop = (op & 0x1000) >> 12;\n  const cop: CommandOps = ((op & 0b0000111111000000) >> 6) as CommandOps;\n  const sop: StoreOps = ((op & 0b0000000000111000) >> 3) as StoreOps;\n  const jop: JumpOps = (op & 0b0000000000000111) as JumpOps;\n\n  if (COMMANDS.op[cop] === undefined) {\n    // Invalid commend\n    return \"#ERR\";\n  }\n\n  let command = COMMANDS.op[cop];\n  if (mop) {\n    command = command.replace(/A/g, \"M\") as COMMANDS_ASM;\n  }\n\n  const store = ASSIGN.op[sop];\n  const jump = JUMP.op[jop];\n\n  let instruction: string = command;\n  if (store) {\n    instruction = `${store}=${instruction}`;\n  }\n  if (jump) {\n    instruction = `${instruction};${jump}`;\n  }\n\n  return instruction;\n}\n\nfunction aInstruction(op: number): string {\n  return \"@\" + (op & 0x7fff).toString(10);\n}\n\nexport function op(asm: string): number {\n  if (asm[0] === \"@\") {\n    return aop(asm);\n  } else {\n    return cop(asm);\n  }\n}\n\nfunction aop(asm: string): number {\n  return parseInt(asm.substring(1), 10);\n}\n\nfunction cop(asm: string): number {\n  const parts = asm.match(\n    /(?:(?<assign>[AMD]{1,3})=)?(?<operation>[-!01ADM&|]{1,3})(?:;(?<jump>JGT|JLT|JGE|JLE|JEQ|JMP))?/\n  );\n  const { assign, operation, jump } = parts?.groups ?? {};\n  const mode = operation.includes(\"M\") || assign.includes(\"M\");\n  const aop = ASSIGN.asm[(assign as ASSIGN_ASM) ?? \"\"];\n  const jop = JUMP.asm[(jump as JUMP_ASM) ?? \"\"];\n  const cop = COMMANDS.asm[(operation as COMMANDS_ASM) ?? \"\"];\n\n  return makeC(mode, cop, aop, jop);\n}\n\nexport function makeC(\n  isM: boolean,\n  op: COMMANDS_OP,\n  assign: ASSIGN_OP = 0,\n  jmp: JUMP_OP = 0\n): number {\n  const C = 0xe000;\n  const A = isM ? 0x1000 : 0;\n  const O = op << 6;\n  const D = (assign ?? 0) << 3;\n  const J = jmp ?? 0;\n  return C + A + O + D + J;\n}\n","const Hex = [\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n];\n\nexport function chars(i: number): string {\n  return Hex[i] ?? \"X\";\n}\n\nexport function bits(i: number): string {\n  switch (i) {\n    case 0x0:\n      return \"0000\";\n    case 0x1:\n      return \"0001\";\n    case 0x2:\n      return \"0010\";\n    case 0x3:\n      return \"0011\";\n    case 0x4:\n      return \"0100\";\n    case 0x5:\n      return \"0101\";\n    case 0x6:\n      return \"0110\";\n    case 0x7:\n      return \"0111\";\n    case 0x8:\n      return \"1000\";\n    case 0x9:\n      return \"1001\";\n    case 0xa:\n      return \"1010\";\n    case 0xb:\n      return \"1011\";\n    case 0xc:\n      return \"1100\";\n    case 0xd:\n      return \"1101\";\n    case 0xe:\n      return \"1110\";\n    case 0xf:\n      return \"1111\";\n    default:\n      return \"erro\";\n  }\n}\n\nexport function int(n: string, radix: number): number {\n  const i = parseInt(n.replace(/[^\\d a-f A-F +-.]/g, \"\"), radix);\n  return i & 0xffff;\n}\n\nexport function int16(i: string): number {\n  return int(i, 16);\n}\n\nexport function int10(i: string): number {\n  return int(i, 10);\n}\n\nexport function int2(i: string): number {\n  return int(i.replaceAll(\" \", \"\"), 2);\n}\n\nexport function parseTwosInt(i: string): number {\n  if (i.toUpperCase().includes(\"X\")) {\n    return int16(i);\n  }\n  return int10(i);\n}\n\nexport function hex(i: number): string {\n  const hu = chars((i & 0xf000) >> 12);\n  const hl = chars((i & 0x0f00) >> 8);\n  const lu = chars((i & 0x00f0) >> 4);\n  const ll = chars(i & 0x000f);\n\n  return `0x${hu}${hl}${lu}${ll}`;\n}\n\nexport function bin(i: number, precision = 16): string {\n  const hu = bits((i & 0xf000) >> 12);\n  const hl = bits((i & 0x0f00) >> 8);\n  const lu = bits((i & 0x00f0) >> 4);\n  const ll = bits(i & 0x000f);\n\n  // return `${hu} ${hl} ${lu} ${ll}`;\n  return `${hu}${hl}${lu}${ll}`.substring(16 - precision); // Match the book's formatting\n}\n\nexport function dec(i: number): string {\n  i = i & 0xffff;\n  if (i === 0x8000) {\n    return \"-32768\";\n  }\n  if (i & 0x8000) {\n    i = (~i + 1) & 0x7fff;\n    return `-${i}`;\n  }\n  return `${i}`;\n}\n\nexport function uns(i: number): string {\n  i = i & 0xffff;\n  return `${i}`;\n}\n\nexport function nand16(a: number, b: number): number {\n  a = a & 0xffff;\n  b = b & 0xffff;\n  let c = ~(a & b);\n  c = c & 0xffff;\n  return c;\n}\n"],"names":["HIGH","LOW","Bus","name","width","state","next","constructor","this","range","map","ensureWidth","newWidth","assert","connect","push","busVoltage","pull","voltage","bit","forEach","n","i","reduce","b","toggle","nextVoltage","InSubBus","bus","start","super","high","mask","low","mid","OutSubBus","ConstantBus","value","pullHigh","pullLow","TRUE_BUS","FALSE_BUS","parsePinDecl","toPin","pin","w","match","groups","Number","Pins","Map","insert","has","set","emplace","minWidth","get","entries","values","Symbol","iterator","id","Chip","ins","outs","pins","parts","Set","clockedPins","clocked","size","part","internals","inn","undefined","out","internal","Clock","$","subscribe","eval","reset","_","in","hasIn","hasOut","offset","getBuiltin","BUILTIN_NAMES","includes","isOutPin","wire","connections","add","to","from","wireOutPin","wireInPin","findPin","toLowerCase","partPin","assertExists","chipPin","isInternal","Error","chip","tick","tock","remove","async","fs","path","load","Low","ClockedChip","level","unsubscribe","Math","pow","clock","ticks","static","isHigh","isLow","subject","BehaviorSubject","frameSubject","Subject","resetSubject","frame$","reset$","frame","toString","COMMANDS_ALU","op","COMMANDS","asm","D","A","M","ASSIGN","MD","AM","AD","AMD","JUMP","JGT","JEQ","JGE","JLT","JNE","JLE","JMP","Flags","Positive","Zero","Negative","alu","d","a","o","FORMATS","SCREEN_OFFSET","SCREEN_SIZE","SCREEN_ROWS","KEYBOARD_OFFSET","Memory","memory","length","Int16Array","index","fill","update","cell","format","current","int2","int16","int10","isFinite","loadBytes","cause","bytes","end","slice","fn","SubMemory","parent","MemoryKeyboard","getKey","setKey","key","clearKey","ROM","program","arr","SIZE","RAM","endsWith","loader","readFile","loadHack","loadAsm","grammar","ohm","asmGrammar","grammars","asmSemantics","extendSemantics","baseSemantics","isAValueInstruction","inst","isALabelInstruction","label","fillLabel","symbolCallback","nextLabel","symbols","unfilled","line","instruction","instructions","type","translateInstruction","makeC","isM","store","jump","addAttribute","Root","child","children","AInstruction","_at","val","span","source","startIdx","endIdx","lineNum","getLineAndColumn","e","CInstruction","assignN","opN","jmpN","assign","sourceString","replace","jmp","Label","_o","_c","ASM","semantics","parser","parse","makeParser","passes","emit","filter","UNKNOWN_PARSE_ERROR","Base","createSemantics","property","root","succeeded","parsed","Ok","Err","message","shortMessage","extendOperation","List","list","asIteration","decNumber","digits","wholeDec","binNumber","hexNumber","num","Name","ident","identifier","__","String","_a","str","_b","unwrap","split","trim","loadBlob","parseTwosInt","mop","cop","sop","jop","command","cInstruction","aInstruction","parseInt","substring","aop","operation","mode","C","O","J","Hex","chars","bits","int","radix","replaceAll","toUpperCase","hex","bin","precision","hu","hl","lu","ll","dec","uns","nand16","c"],"sourceRoot":""}