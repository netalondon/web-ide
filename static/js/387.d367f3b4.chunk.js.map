{"version":3,"file":"static/js/387.d367f3b4.chunk.js","mappings":"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","sources":["../../components/src/difftable.tsx","../../node_modules/@davidsouther/jiffies/lib/esm/display.js","../../simulator/src/cpu/cpu.ts","../../simulator/src/languages/grammars/cmp.ohm.js","../../simulator/src/languages/cmp.ts","../../simulator/src/languages/grammars/tst.ohm.js","../../simulator/src/languages/tst.ts","../../simulator/src/output.ts","../../simulator/src/tst.ts"],"sourcesContent":["import { CMP } from \"@nand2tetris/simulator/languages/cmp.js\";\nimport { display } from \"@davidsouther/jiffies/lib/esm/display.js\";\nimport { range } from \"@davidsouther/jiffies/lib/esm/range.js\";\nimport { Err, isErr, Ok } from \"@davidsouther/jiffies/lib/esm/result.js\";\nimport { ReactElement } from \"react\";\n\nexport const DiffTable = ({\n  className = \"\",\n  out,\n  cmp,\n  zeroState,\n}: {\n  out: string;\n  cmp: string;\n  className?: string;\n  zeroState?: ReactElement;\n}) => {\n  const output = CMP.parse(out);\n  const compare = CMP.parse(cmp);\n\n  if (isErr(output)) {\n    return (\n      <details>\n        <summary>Failed to parse output</summary>\n        <pre>{display(Err(output))}</pre>\n        <code>\n          <pre>{out}</pre>\n        </code>\n      </details>\n    );\n  }\n\n  if (isErr(compare)) {\n    return (\n      <details>\n        <summary>Failed to parse compare</summary>\n        <code>\n          <pre>{display(Err(compare))}</pre>\n          <pre>{cmp}</pre>\n        </code>\n      </details>\n    );\n  }\n\n  const cmpData = Ok(compare);\n  const outData = Ok(output);\n  let failures = 0;\n  const table = range(0, Math.min(cmpData.length, outData.length)).map((i) => {\n    const cmpI = cmpData[i] ?? [];\n    const outI = outData[i] ?? [];\n    return range(0, Math.max(cmpI.length, outI.length))\n      .map((_, j) => [cmpI[j] ?? \"\", outI[j] ?? \"\"])\n      .map(([cmp, out]) => {\n        const cell = {\n          cmp: cmp ?? '\"',\n          out: out ?? '\"',\n          pass:\n            cmp?.trim().match(/^\\*+$/) !== null || out?.trim() === cmp?.trim(),\n        };\n        if (!cell.pass) {\n          failures += 1;\n        }\n        return cell;\n      });\n  });\n\n  return (\n    <div className={\"scroll-x \" + className}>\n      {failures > 0 && (\n        <p>\n          {failures} failure{failures === 1 ? \"\" : \"s\"}\n        </p>\n      )}\n      {table.length > 0 ? (\n        <table\n          style={{\n            fontFamily: \"var(--font-family-monospace)\",\n            marginBottom: \"none\",\n          }}\n        >\n          <tbody>\n            {table.map((row, i) => (\n              <tr key={i}>\n                {row.map(({ cmp, out, pass }, i) => (\n                  <DiffCell cmp={cmp} out={out} pass={pass} key={i} />\n                ))}\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      ) : (\n        zeroState ?? <p>Execute test script to compare output.</p>\n      )}\n    </div>\n  );\n};\n\nconst DiffCell = ({\n  cmp,\n  out,\n  pass,\n}: {\n  cmp: string;\n  out: string;\n  pass: boolean;\n}) => {\n  return pass ? (\n    <>\n      <td>{cmp}</td>\n    </>\n  ) : (\n    <>\n      <td>\n        <ins>{cmp}</ins>\n        <br />\n        <del>{out}</del>\n      </td>\n    </>\n  );\n};\n","export const isDisplay = (a) => typeof a?.toString === \"function\" ||\n    typeof a === \"string\";\nexport const display = (a) => {\n    if (isDisplay(a)) {\n        const str = a.toString();\n        if (str === \"[object Object]\")\n            return JSON.stringify(a);\n        return str;\n    }\n    return JSON.stringify(a);\n};\n","import { alu, COMMANDS_OP, Flags } from \"./alu.js\";\nimport {\n  Memory,\n  MemoryAdapter,\n  MemoryKeyboard,\n  SubMemory,\n  RAM as RAMMem,\n  SCREEN_OFFSET,\n  SCREEN_SIZE,\n} from \"./memory.js\";\n\nexport interface CPUInput {\n  inM: number;\n  instruction: number;\n  reset: boolean;\n}\n\nexport interface CPUOutput {\n  outM: number;\n  writeM: boolean;\n  addressM: number;\n}\n\nexport interface CPUState {\n  A: number;\n  D: number;\n  PC: number;\n  ALU: number;\n  flag: number;\n}\n\nexport function emptyState(): CPUState {\n  return { A: 0, D: 0, PC: 0, ALU: 0, flag: Flags.Zero };\n}\n\nconst BITS = {\n  c: 0b1000_0000_0000_0000,\n  x1: 0b1001_0000_0000_0000,\n  x2: 0b1001_0000_0000_0000,\n  am: 0b1001_0000_0000_0000,\n  op: 0b0000_1111_1100_0000,\n  d1: 0b1000_0000_0010_0000,\n  d2: 0b1000_0000_0001_0000,\n  d3: 0b1000_0000_0000_1000,\n  j1: 0b1000_0000_0000_0001,\n  j2: 0b1000_0000_0000_0010,\n  j3: 0b1000_0000_0000_0100,\n};\n\nexport function decode(instruction: number) {\n  function bit(bit: number): boolean {\n    return (instruction & bit) === bit;\n  }\n  const bits = {\n    c: bit(BITS.c),\n    x1: bit(BITS.x1),\n    x2: bit(BITS.x2),\n    am: bit(BITS.am),\n    op: ((instruction & BITS.op) >> 6) as COMMANDS_OP,\n    d1: bit(BITS.d1),\n    d2: bit(BITS.d2),\n    d3: bit(BITS.d3),\n    j1: bit(BITS.j1),\n    j2: bit(BITS.j2),\n    j3: bit(BITS.j3),\n  };\n\n  return bits;\n}\n\nexport function cpuTick(\n  { inM, instruction }: CPUInput,\n  { A, D, PC }: CPUState\n): [CPUState, boolean] {\n  const bits = decode(instruction);\n  const a = bits.am ? inM : A;\n  const [ALU, flag] = alu(bits.op, D, a);\n\n  return [{ A, D, PC: PC + 1, ALU, flag }, bits.d3];\n}\n\nexport function cpuTock(\n  { inM, instruction, reset }: CPUInput,\n  { A, D, PC, ALU, flag }: CPUState\n): [CPUOutput, CPUState] {\n  const bits = decode(instruction);\n\n  const j1 = bits.j1 && flag === Flags.Positive;\n  const j2 = bits.j2 && flag === Flags.Zero;\n  const j3 = bits.j3 && flag === Flags.Negative;\n  const jmp = j1 || j2 || j3;\n\n  PC = reset ? 0 : jmp ? A : PC;\n\n  if (bits.d2) {\n    D = ALU;\n  }\n\n  const oldA = A;\n  if (!bits.c) {\n    A = instruction & 0x7fff;\n  } else if (bits.d1) {\n    A = ALU;\n  }\n\n  const a = bits.am ? inM : A;\n  const alu2 = alu(bits.op, D, a);\n\n  ALU = alu2[0];\n  flag = alu2[1];\n\n  const output: CPUOutput = {\n    addressM: bits.d3 ? oldA : A,\n    outM: ALU,\n    writeM: bits.d3,\n  };\n\n  const state: CPUState = {\n    A,\n    D,\n    ALU,\n    flag,\n    PC,\n  };\n\n  return [output, state];\n}\n\nexport function cpu(input: CPUInput, state: CPUState): [CPUOutput, CPUState] {\n  const [tickState, _writeM] = cpuTick(input, state);\n  return cpuTock(input, tickState);\n}\n\nexport class CPU {\n  readonly RAM: Memory;\n  readonly ROM: Memory;\n  readonly Screen: MemoryAdapter;\n  readonly Keyboard: MemoryKeyboard;\n\n  #pc = 0;\n  #a = 0;\n  #d = 0;\n\n  #tickState: CPUState = {\n    A: 0,\n    D: 0,\n    PC: 0,\n    ALU: 0,\n    flag: Flags.Zero,\n  };\n\n  get state(): CPUState {\n    return this.#tickState;\n  }\n\n  get PC() {\n    return this.#pc;\n  }\n\n  get A() {\n    return this.#a;\n  }\n\n  get D() {\n    return this.#d;\n  }\n\n  setA(value: number) {\n    this.#a = value;\n  }\n\n  setD(value: number) {\n    this.#d = value;\n  }\n\n  setPC(value: number) {\n    this.#pc = value;\n  }\n\n  constructor({ RAM = new RAMMem(), ROM }: { RAM?: Memory; ROM: Memory }) {\n    this.RAM = RAM;\n    this.ROM = ROM;\n\n    // \"Device Map\"\n    this.Screen = new SubMemory(this.RAM, SCREEN_SIZE, SCREEN_OFFSET);\n    this.Keyboard = new MemoryKeyboard(this.RAM);\n  }\n\n  reset() {\n    this.#pc = 0;\n    this.#a = 0;\n    this.#d = 0;\n  }\n\n  tick() {\n    const [{ addressM, outM, writeM }, { A, D, PC }] = cpu(\n      {\n        inM: this.RAM.get(this.#a),\n        instruction: this.ROM.get(this.#pc),\n        reset: false,\n      },\n      {\n        A: this.#a,\n        D: this.#d,\n        PC: this.#pc,\n        ALU: this.#d,\n        flag: Flags.Zero,\n      }\n    );\n\n    this.#a = A;\n    this.#d = D;\n    this.#pc = PC;\n\n    if (writeM) {\n      this.RAM.set(addressM, outM);\n    }\n  }\n}\n","const cmp = `\nCmp <: Base {\n  Root := line*\n  line = bar cell+ newline?\n  cell = cellvalue bar\n  cellvalue = (~(bar|newline) any)*\n}`;\nexport default cmp;\n","import ohm from \"ohm-js\";\nimport { grammars, makeParser, baseSemantics } from \"./base.js\";\n\nexport type Cell = string;\nexport type Line = Cell[];\nexport type Cmp = Line[];\n\nimport cmpGrammar from \"./grammars/cmp.ohm.js\";\nexport const grammar = ohm.grammar(cmpGrammar, grammars);\nexport const cmpSemantics = grammar.extendSemantics(baseSemantics);\n\ncmpSemantics.addAttribute<Cell>(\"cell\", {\n  cell(value, _) {\n    return value.sourceString;\n  },\n});\n\ncmpSemantics.addAttribute<Line>(\"line\", {\n  line(_a, cells, _b) {\n    return cells.children.map((c) => c.cell);\n  },\n});\n\ncmpSemantics.addAttribute<Cmp>(\"root\", {\n  Root(lines) {\n    return lines.children.map((c) => c.line);\n  },\n});\n\nexport const CMP = {\n  grammar: cmpGrammar,\n  semantics: cmpSemantics,\n  parser: grammar,\n  parse: makeParser<Cmp>(grammar, cmpSemantics),\n};\n","const tst = `\nTst <: Base {\n  Root := Tst\n  Tst = (TstStatement | TstRepeat | TstWhile)+\n\n  TstRepeat = Repeat Number? OpenBrace TstStatement+ CloseBrace\n  TstWhile = While Condition OpenBrace TstStatement+ CloseBrace\n  TstStatement = List<TstOperation, \",\"> (Semi | Bang)\n\n  TstOperation =\n    | TstFileOperation\n    | TstOutputListOperation\n    | TstEvalOperation\n    | TstSetOperation\n    | TstOutputOperation\n    | TstEchoOperation\n    | TstClearEchoOperation\n    | TstLoadROMOperation\n\n  TstLoadROMOperation = ROM32K Load FileName\n  TstFileOperation = FileOperation FileName\n  TstOutputListOperation = \"output-list\" OutputFormat+\n  OutputFormat = Name Index? percent FormatStyle wholeDec dot wholeDec dot wholeDec\n  TstSetOperation = Set Name Index? Number\n  Index = OpenSquare wholeDec? CloseSquare\n  Condition = Value CompareOp Value\n  TstEvalOperation = Eval | TickTock| Tick | Tock\n  TstOutputOperation = Output\n  TstEchoOperation = Echo String\n  TstClearEchoOperation = ClearEcho\n\n  FileName = Name\n  FileOperation = \"load\" | \"output-file\" | \"compare-to\"\n\n  Set = \"set\"\n  Eval = \"eval\"\n  Tick = \"tick\"\n  Tock = \"tock\"\n  TickTock = \"ticktock\"\n  Echo = \"echo\"\n  Repeat = \"repeat\"\n  ClearEcho = \"clear-echo\"\n  Output = \"output\"\n  OutputList = \"output-list\"\n  FormatStyle = \"B\"|\"D\"|\"S\"|\"X\"\n  ROM32K = \"ROM32K\"\n  Load = \"load\"\n  While = \"while\"\n\n  CompareOp = \"<>\" | \"<=\" | \">=\" | \"=\" | \"<\" | \">\"\n}`;\nexport default tst;\n","/** Reads tst files to apply and perform test runs. */\n\nimport ohm from \"ohm-js\";\nimport { baseSemantics, grammars, makeParser, Span } from \"./base.js\";\n\nexport interface TstEchoOperation {\n  op: \"echo\";\n  message: string;\n}\n\nexport interface TstClearEchoOperation {\n  op: \"clear-echo\";\n}\n\nexport interface TstSetOperation {\n  op: \"set\";\n  id: string;\n  index?: number;\n  value: number;\n}\n\nexport interface TstEvalOperation {\n  op: \"eval\" | \"tick\" | \"tock\" | \"ticktock\";\n}\n\nexport interface TstOutputOperation {\n  op: \"output\";\n}\n\nexport interface TstOutputSpec {\n  id: string;\n  builtin: boolean;\n  address: number;\n  style: \"D\" | \"X\" | \"B\" | \"S\";\n  width: number;\n  lpad: number;\n  rpad: number;\n}\n\nexport interface TstOutputListOperation {\n  op: \"output-list\";\n  spec: TstOutputSpec[];\n}\n\nexport interface TstLoadROMOperation {\n  op: \"loadRom\";\n  file: string;\n}\n\nexport interface TstFileOperation {\n  op: \"load\" | \"output-file\" | \"compare-to\";\n  file: string;\n}\n\nexport type TstOperation =\n  | TstFileOperation\n  | TstEvalOperation\n  | TstEchoOperation\n  | TstClearEchoOperation\n  | TstOutputOperation\n  | TstSetOperation\n  | TstOutputListOperation\n  | TstLoadROMOperation;\n\nexport interface TstLineStatement {\n  ops: TstOperation[];\n  break?: true;\n  span: Span;\n}\n\nexport interface TstRepeat {\n  statements: TstLineStatement[];\n  count: number;\n  span: Span;\n}\n\nexport interface TstWhileCondition {\n  op: \"<\" | \"<=\" | \"=\" | \">=\" | \">\" | \"<>\";\n  left: string | number;\n  right: string | number;\n}\n\nexport interface TstWhileStatement {\n  statements: TstLineStatement[];\n  condition: TstWhileCondition;\n  span: Span;\n}\n\nexport type TstStatement = TstLineStatement | TstRepeat | TstWhileStatement;\n\nexport interface Tst {\n  lines: TstStatement[];\n}\n\nimport tstGrammar from \"./grammars/tst.ohm.js\";\nexport const grammar = ohm.grammar(tstGrammar, grammars);\nexport const tstSemantics = grammar.extendSemantics(baseSemantics);\n\ntstSemantics.extendAttribute<number>(\"value\", {\n  Index(_a, idx, _b) {\n    return idx?.child(0)?.value ?? -1;\n  },\n});\n\ntstSemantics.extendAttribute<string>(\"name\", {\n  FileName({ name }) {\n    return name;\n  },\n});\n\ntstSemantics.addAttribute<number>(\"index\", {\n  Index(_open, dec, _close) {\n    return dec.child(0)?.value ?? 0;\n  },\n});\n\ntstSemantics.addAttribute<TstOutputSpec>(\"format\", {\n  OutputFormat(\n    { name: id },\n    index,\n    _a,\n    { sourceString: style },\n    { value: lpad },\n    _b,\n    { value: width },\n    _c,\n    { value: rpad }\n  ) {\n    return {\n      id,\n      builtin: index?.child(0) !== undefined,\n      address: index?.child(0)?.value ?? -1,\n      style: style as TstOutputSpec[\"style\"],\n      width,\n      lpad,\n      rpad,\n    };\n  },\n});\n\ntstSemantics.addAttribute<TstOperation>(\"operation\", {\n  TstEvalOperation(op) {\n    return { op: op.sourceString as TstEvalOperation[\"op\"] };\n  },\n  TstOutputOperation(_) {\n    return { op: \"output\" };\n  },\n  TstOutputListOperation(_, formats) {\n    return {\n      op: \"output-list\",\n      spec: formats.children.map((n) => n.format),\n    };\n  },\n  TstSetOperation(op, { name }, index, { value }) {\n    const setOp: TstSetOperation = {\n      op: \"set\",\n      id: name,\n      value,\n    };\n    const child = index.child(0)?.child(1)?.child(0);\n    if (child) {\n      setOp.index = child.value;\n    }\n    return setOp;\n  },\n  TstEchoOperation(op, str) {\n    return {\n      op: \"echo\",\n      message: str.String as string,\n    };\n  },\n  TstClearEchoOperation(op) {\n    return {\n      op: \"clear-echo\",\n    };\n  },\n  TstLoadROMOperation(_r, _l, { name }) {\n    return {\n      op: \"loadRom\",\n      file: name,\n    };\n  },\n  TstFileOperation(op, file) {\n    return {\n      op: op.sourceString as TstFileOperation[\"op\"],\n      file: file.sourceString,\n    };\n  },\n});\n\ntstSemantics.addAttribute<TstWhileCondition>(\"condition\", {\n  Condition({ value: left }, { sourceString: op }, { value: right }) {\n    return {\n      left,\n      right,\n      op: op as \"<\" | \"<=\" | \"=\" | \">=\" | \">\" | \"<>\",\n    };\n  },\n});\n\ntstSemantics.addAttribute<TstStatement>(\"statement\", {\n  TstWhile(op, cond, _o, statements, _c) {\n    return {\n      statements: statements.children.map(({ statement }) => statement),\n      condition: cond.condition,\n      span: {\n        start: op.source.startIdx,\n        end: cond.source.endIdx,\n      },\n    };\n  },\n  TstRepeat(op, count, _o, statements, _c) {\n    return {\n      statements: statements.children.map(({ statement }) => statement),\n      count: count.child(0)?.value ?? -1,\n      span: {\n        start: op.source.startIdx,\n        end: count.source.endIdx,\n      },\n    };\n  },\n  TstStatement(list, end) {\n    const stmt: TstStatement = {\n      ops: list\n        .asIteration()\n        .children.map((node) => node.operation as TstOperation),\n      span: {\n        start: this.source.startIdx,\n        end: this.source.endIdx,\n      },\n    };\n    if (end.sourceString === \"!\") {\n      stmt.break = true;\n    }\n    return stmt;\n  },\n});\n\ntstSemantics.addAttribute<Tst>(\"tst\", {\n  Tst(lines) {\n    return {\n      lines: lines.children.map((n) => n.statement),\n    };\n  },\n});\n\ntstSemantics.addAttribute<Tst>(\"root\", {\n  Root({ tst }) {\n    return tst;\n  },\n});\n\nexport const TST = {\n  grammar: tstGrammar,\n  semantics: tstSemantics,\n  parser: grammar,\n  parse: makeParser<Tst>(grammar, tstSemantics),\n};\n","import { assert } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { bin, dec, hex } from \"./util/twos.js\";\nimport { Test } from \"./tst.js\";\n\nexport class Output {\n  private readonly fmt: \"B\" | \"X\" | \"D\" | \"S\";\n  private readonly lPad: number;\n  private readonly rPad: number;\n  private readonly len: number;\n  private readonly index: number;\n  private readonly builtin: boolean;\n\n  // new Output(inst.id, inst.style, inst.width, inst.lpad, inst.rpad)\n  constructor(\n    private variable: string,\n    format = \"%B1.1.1\",\n    len?: number,\n    lPad?: number,\n    rPad?: number,\n    builtin?: boolean,\n    index?: number\n  ) {\n    if (\n      format.startsWith(\"%\") &&\n      len === undefined &&\n      lPad === undefined &&\n      rPad === undefined\n    ) {\n      const { fmt, lPad, rPad, len } = format.match(\n        /^%(?<fmt>[BDXS])(?<lPad>\\d+)\\.(?<len>\\d+)\\.(?<rPad>\\d+)$/\n      )?.groups as {\n        fmt: \"B\" | \"X\" | \"D\" | \"S\";\n        lPad: string;\n        rPad: string;\n        len: string;\n      };\n      this.fmt = fmt;\n      this.lPad = parseInt(lPad);\n      this.rPad = parseInt(rPad);\n      this.len = parseInt(len);\n      this.builtin = false;\n      this.index = -1;\n    } else {\n      assert([\"B\", \"X\", \"D\", \"S\"].includes(format[0]));\n      this.fmt = format[0] as \"B\" | \"X\" | \"D\" | \"S\";\n      this.len = len ?? 3;\n      this.lPad = lPad ?? 1;\n      this.rPad = rPad ?? 1;\n      this.builtin = builtin ?? false;\n      this.index = index ?? -1;\n    }\n  }\n\n  header(test: Test) {\n    let variable = `${this.variable}`;\n    if (this.builtin) {\n      const index = this.index >= 0 ? this.index : \"\";\n      variable = `${variable}[${index}]`;\n    }\n    if (variable.length > this.len + this.lPad + this.rPad) {\n      return variable.substring(0, this.len + this.lPad + this.rPad);\n    }\n    return this.padCenter(variable);\n  }\n\n  print(test: Test) {\n    const val = test.getVar(this.variable, this.index);\n    if (this.fmt === \"S\") {\n      return this.padLeft(val as string);\n    }\n\n    const fmt = { B: bin, D: dec, X: hex }[this.fmt];\n    const value = fmt(val as number);\n    if (this.fmt === \"D\") {\n      return this.padRight(value);\n    } else {\n      return this.padCenter(value.slice(value.length - this.len));\n    }\n  }\n\n  private padCenter(value: string) {\n    const space = this.lPad + this.len + this.rPad;\n    const leftSpace = Math.floor((space - value.length) / 2);\n    const rightSpace = space - leftSpace - value.length;\n    const padLeft = leftSpace + value.length;\n    const padRight = padLeft + rightSpace;\n    value = value.padStart(padLeft);\n    value = value.padEnd(padRight);\n    return value;\n  }\n\n  private padLeft(value: string) {\n    value = value.substring(0, this.len);\n    const padRight = this.rPad + this.len;\n    const padLeft = this.lPad + padRight;\n    value = value.padEnd(padRight);\n    value = value.padStart(padLeft);\n    return value;\n  }\n\n  private padRight(value: string) {\n    value = value.substring(0, this.len);\n    const padLeft = this.lPad + this.len;\n    const padRight = this.rPad + padLeft;\n    value = value.padStart(padLeft);\n    value = value.padEnd(padRight);\n    return value;\n  }\n}\n","import {\n  assertExists,\n  checkExhaustive,\n} from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport { Span } from \"./languages/base.js\";\nimport {\n  Tst,\n  TstLineStatement,\n  TstOperation,\n  TstOutputSpec,\n  TstStatement,\n  TstWhileStatement,\n} from \"./languages/tst.js\";\nimport { Bus, Chip, HIGH, Low, LOW } from \"./chip/chip.js\";\nimport { Clock } from \"./chip/clock.js\";\nimport { Output } from \"./output.js\";\nimport { ROM } from \"./cpu/memory.js\";\nimport { CPU } from \"./cpu/cpu.js\";\n\nexport abstract class Test<IS extends TestInstruction = TestInstruction> {\n  protected readonly instructions: (IS | TestInstruction)[] = [];\n  protected _outputList: Output[] = [];\n  protected _log = \"\";\n  fs: FileSystem = new FileSystem();\n\n  setFileSystem(fs: FileSystem): this {\n    this.fs = fs;\n    return this;\n  }\n\n  echo(_content: string) {\n    return undefined;\n  }\n  clearEcho() {\n    return undefined;\n  }\n\n  async load(_filename: string): Promise<void> {\n    return undefined;\n  }\n  async compareTo(_filename: string): Promise<void> {\n    return undefined;\n  }\n  outputFile(_filename: string): void {\n    return undefined;\n  }\n  outputList(outputs: Output[]): void {\n    this._outputList = outputs;\n  }\n\n  addInstruction(instruction: IS | TestInstruction): void {\n    this.instructions.push(instruction);\n  }\n\n  reset(): this {\n    this._steps = (function* (test) {\n      for (const instruction of test.instructions) {\n        yield* instruction.steps(test);\n      }\n    })(this);\n    this._step = this._steps.next();\n    this._step; //?\n    this._log = \"\";\n    return this;\n  }\n\n  private _steps!: IterableIterator<IS | TestInstruction>;\n  private _step!: IteratorResult<IS | TestInstruction, IS | TestInstruction>;\n\n  get steps(): Iterator<IS | TestInstruction> {\n    if (this._steps === undefined) {\n      this.reset();\n      this._steps = assertExists(this._steps, \"Reset did not initialize steps\");\n      this._step = assertExists(this._step, \"Reset did not find first step\");\n    }\n    return this._steps;\n  }\n\n  get currentStep(): IS | TestInstruction | undefined {\n    return this._step?.value;\n  }\n\n  get done(): boolean {\n    return this._step?.done ?? false;\n  }\n\n  step() {\n    if (!this._step.done) {\n      this._step.value.do(this);\n      this._step = this.steps.next();\n      return false;\n    }\n    return true;\n  }\n\n  async run() {\n    this.reset();\n    while (!(await this.step()));\n  }\n\n  protected readonly breakpoints: Map<string, number> = new Map();\n  addBreakpoint(variable: string, value: number) {\n    this.breakpoints.set(variable, value);\n  }\n  clearBreakpoints() {\n    this.breakpoints.clear();\n  }\n\n  output() {\n    const values = this._outputList.map((output) => output.print(this));\n    this._log += `|${values.join(\"|\")}|\\n`;\n  }\n\n  header() {\n    const values = this._outputList.map((output) => output.header(this));\n    this._log += `|${values.join(\"|\")}|\\n`;\n  }\n\n  log() {\n    return this._log;\n  }\n\n  abstract hasVar(variable: string | number): boolean;\n  abstract getVar(variable: string | number, offset?: number): number | string;\n  abstract setVar(variable: string, value: number, offset?: number): void;\n}\n\nfunction isTstLineStatment(line: TstStatement): line is TstLineStatement {\n  return (line as TstLineStatement).ops !== undefined;\n}\n\nfunction isTstWhileStatement(line: TstStatement): line is TstWhileStatement {\n  return (line as TstWhileStatement).condition !== undefined;\n}\n\nfunction makeLineStatement(line: TstLineStatement) {\n  const statement = new TestCompoundInstruction();\n  statement.span = line.span;\n  for (const op of line.ops) {\n    const inst = makeInstruction(op);\n    if (inst !== undefined) statement.addInstruction(inst);\n  }\n  return statement;\n}\n\nfunction makeInstruction(inst: TstOperation) {\n  const { op } = inst;\n  switch (op) {\n    case \"tick\":\n      return new TestTickInstruction();\n    case \"tock\":\n      return new TestTockInstruction();\n    case \"ticktock\":\n      return new TestTickTockInstruction();\n    case \"eval\":\n      return new TestEvalInstruction();\n    case \"output\":\n      return new TestOutputInstruction();\n    case \"set\":\n      return new TestSetInstruction(inst.id, inst.value, inst.index);\n    case \"output-list\":\n      return new TestOutputListInstruction(inst.spec);\n    case \"echo\":\n      return new TestEchoInstruction(inst.message);\n    case \"clear-echo\":\n      return new TestClearEchoInstruction();\n    case \"loadRom\":\n      return new TestLoadROMInstruction(inst.file);\n    case \"load\":\n    case \"output-file\":\n    case \"compare-to\":\n      return undefined;\n    default:\n      checkExhaustive(op, `Unknown tst operation ${op}`);\n  }\n}\n\nfunction fill<T extends Test>(test: T, tst: Tst): T {\n  for (const line of tst.lines) {\n    if (isTstLineStatment(line)) {\n      test.addInstruction(makeLineStatement(line));\n    } else {\n      const repeat = isTstWhileStatement(line)\n        ? new TestWhileInstruction(\n            new Condition(\n              line.condition.left,\n              line.condition.right,\n              line.condition.op\n            )\n          )\n        : new TestRepeatInstruction(line.count);\n      repeat.span = line.span;\n      test.addInstruction(repeat);\n      for (const statement of line.statements) {\n        repeat.addInstruction(makeLineStatement(statement));\n      }\n    }\n  }\n\n  test.reset();\n\n  return test;\n}\n\nexport class ChipTest extends Test<ChipTestInstruction> {\n  private chip: Chip = new Low();\n  get chipId(): number {\n    return this.chip.id;\n  }\n\n  private clock = Clock.get();\n\n  static from(tst: Tst): ChipTest {\n    const test = new ChipTest();\n    return fill(test, tst);\n  }\n\n  with(chip: Chip): this {\n    this.chip = chip;\n    return this;\n  }\n\n  hasVar(variable: string | number): boolean {\n    if (variable === \"time\") {\n      return true;\n    }\n    variable = `${variable}`;\n    // Look up built-in chip state variables\n    return this.chip.hasIn(variable) || this.chip.hasOut(variable);\n  }\n\n  getVar(variable: string | number, offset?: number): number | string {\n    variable = `${variable}`;\n    if (variable === \"time\") {\n      return this.clock.toString();\n    }\n    const pin = this.chip.get(variable, offset);\n    if (!pin) return 0;\n    return pin instanceof Bus ? pin.busVoltage : pin.voltage();\n  }\n\n  setVar(variable: string, value: number, offset?: number): void {\n    // Look up built-in chip state variables\n    const pinOrBus = this.chip.get(variable, offset);\n    if (pinOrBus instanceof Bus) {\n      pinOrBus.busVoltage = value;\n    } else {\n      pinOrBus?.pull(value === 0 ? LOW : HIGH);\n    }\n  }\n\n  eval(): void {\n    this.chip.eval();\n  }\n\n  tick(): void {\n    this.chip.eval();\n    this.clock.tick();\n  }\n\n  tock(): void {\n    this.chip.eval();\n    this.clock.tock();\n  }\n\n  override async load(filename: string) {\n    await this.chip.load(this.fs, filename);\n  }\n\n  override async run() {\n    this.clock.reset();\n    await super.run();\n  }\n}\n\nexport class CPUTest extends Test<CPUTestInstruction> {\n  readonly cpu: CPU;\n  private ticks = 0;\n\n  static from(tst: Tst, rom?: ROM): CPUTest {\n    const test = new CPUTest(rom);\n    return fill(test, tst);\n  }\n\n  constructor(rom: ROM = new ROM(new Int16Array())) {\n    super();\n    this.cpu = new CPU({ ROM: rom });\n    this.reset();\n  }\n\n  override reset(): this {\n    super.reset();\n    this.cpu.reset();\n    this.ticks = 0;\n    return this;\n  }\n\n  hasVar(variable: string | number): boolean {\n    if (typeof variable === \"number\") {\n      return false;\n    }\n    // A: Current value of the address register (unsigned 15-bit);\n    // D: Current value of the data register (16-bit);\n    // PC: Current value of the Program Counter (unsigned 15-bit);\n    // RAM[i]: Current value of RAM location i (16-bit);\n    // time: Number of time units (also called clock cycles, or ticktocks) that elapsed since the simulation started (a read-only system variable).\n    if (\n      variable === \"A\" ||\n      variable === \"D\" ||\n      variable === \"PC\" ||\n      variable === \"time\" ||\n      variable.startsWith(\"RAM\")\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  getVar(variable: string | number, offset?: number): number {\n    switch (variable) {\n      case \"A\":\n        return this.cpu.A;\n      case \"D\":\n        return this.cpu.D;\n      case \"PC\":\n        return this.cpu.PC;\n      case \"time\":\n        return this.ticks;\n      case \"RAM\":\n        return offset === undefined ? 0 : this.cpu.RAM.get(offset);\n    }\n    if (typeof variable === \"number\") return 0;\n    return 0;\n  }\n\n  setVar(variable: string, value: number, index?: number): void {\n    // A: Current value of the address register (unsigned 15-bit);\n    // D: Current value of the data register (16-bit);\n    // PC: Current value of the Program Counter (unsigned 15-bit);\n    // RAM[i]: Current value of RAM location i (16-bit);\n    switch (variable) {\n      case \"A\":\n        this.cpu.setA(value);\n        break;\n      case \"D\":\n        this.cpu.setD(value);\n        break;\n      case \"PC\":\n        this.cpu.setPC(value);\n        break;\n      case \"RAM\":\n        this.cpu.RAM.set(index ?? 0, value);\n        break;\n    }\n    return;\n  }\n\n  ticktock(): void {\n    this.ticks += 1;\n    this.cpu.tick();\n  }\n\n  override async load(filename: string): Promise<void> {\n    await this.cpu.ROM.load(this.fs, filename);\n  }\n}\n\nexport class VMTest extends Test<VMTestInstruction> {\n  hasVar(_variable: string | number): boolean {\n    return false;\n  }\n  getVar(_variable: string | number): number {\n    return 0;\n  }\n  setVar(_variable: string, _value: number): void {\n    return undefined;\n  }\n  vmstep(): void {\n    return undefined;\n  }\n}\n\nexport interface TestInstruction {\n  span?: Span;\n  do(test: Test): void;\n  steps(test: Test): IterableIterator<TestInstruction>;\n}\n\nexport class TestSetInstruction implements TestInstruction {\n  constructor(\n    private variable: string,\n    private value: number,\n    private index?: number | undefined\n  ) {}\n\n  do(test: Test) {\n    test.setVar(this.variable, this.value, this.index);\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestOutputInstruction implements TestInstruction {\n  do(test: Test) {\n    test.output();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestOutputListInstruction implements TestInstruction {\n  private outputs: Output[] = [];\n\n  constructor(specs: TstOutputSpec[] = []) {\n    for (const spec of specs) {\n      this.addOutput(spec);\n    }\n  }\n\n  addOutput(inst: TstOutputSpec) {\n    this.outputs.push(\n      new Output(\n        inst.id,\n        inst.style,\n        inst.width,\n        inst.lpad,\n        inst.rpad,\n        inst.builtin,\n        inst.address\n      )\n    );\n  }\n\n  do(test: Test) {\n    test.outputList(this.outputs);\n    test.header();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestCompoundInstruction implements TestInstruction {\n  protected readonly instructions: TestInstruction[] = [];\n  span?: Span;\n\n  addInstruction(instruction: TestInstruction) {\n    this.instructions.push(instruction);\n  }\n\n  do(test: Test<TestInstruction>): void {\n    for (const instruction of this.instructions) {\n      instruction.do(test);\n    }\n  }\n\n  *steps(_test: Test): Generator<TestInstruction> {\n    yield this;\n  }\n}\n\nexport class TestRepeatInstruction extends TestCompoundInstruction {\n  constructor(public readonly repeat: number) {\n    super();\n  }\n\n  override do() {\n    return undefined;\n  }\n\n  private *innerSteps(test: Test) {\n    for (const instruction of this.instructions) {\n      yield* instruction.steps(test);\n    }\n  }\n\n  override *steps(test: Test) {\n    if (this.repeat === -1) {\n      yield this;\n      while (true) {\n        yield* this.innerSteps(test);\n      }\n    } else {\n      for (let i = 0; i < this.repeat; i++) {\n        yield this;\n        yield* this.innerSteps(test);\n      }\n    }\n  }\n}\n\nexport class Condition {\n  constructor(\n    public readonly x: string | number,\n    public readonly y: string | number,\n    public readonly op: \"<\" | \"<=\" | \"=\" | \">=\" | \">\" | \"<>\"\n  ) {}\n\n  check(test: Test): boolean {\n    const x = test.hasVar(this.x) ? test.getVar(this.x) : this.x;\n    const y = test.hasVar(this.y) ? test.getVar(this.y) : this.y;\n\n    if (typeof x === \"string\" || typeof y === \"string\") {\n      switch (this.op) {\n        case \"=\":\n          return `${x}` === `${y}`;\n        case \"<>\":\n          return `${x}` !== `${y}`;\n      }\n    } else {\n      switch (this.op) {\n        case \"<\":\n          return x < y;\n        case \"<=\":\n          return x <= y;\n        case \">\":\n          return x > y;\n        case \">=\":\n          return x >= y;\n        case \"=\":\n          return x === y;\n        case \"<>\":\n          return x !== y;\n      }\n    }\n    return false;\n  }\n}\n\nexport class TestWhileInstruction extends TestCompoundInstruction {\n  constructor(public readonly condition: Condition) {\n    super();\n  }\n\n  override *steps(test: Test) {\n    while (this.condition.check(test)) {\n      yield this;\n      for (const instruction of this.instructions) {\n        yield* instruction.steps(test);\n      }\n    }\n  }\n}\n\nexport class TestEchoInstruction implements TestInstruction {\n  constructor(public readonly content: string) {}\n  do(test: Test) {\n    test.echo(this.content);\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestClearEchoInstruction implements TestInstruction {\n  do(test: Test) {\n    test.clearEcho();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestLoadROMInstruction implements TestInstruction {\n  constructor(readonly file: string) {}\n  async do(test: Test) {\n    test.fs.pushd(\"/test\");\n    await test.load(this.file);\n    test.fs.popd();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestBreakpointInstruction implements TestInstruction {\n  constructor(readonly variable: string, readonly value: number) {}\n\n  do(test: Test) {\n    test.addBreakpoint(this.variable, this.value);\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestClearBreakpointsInstruction implements TestInstruction {\n  do(test: Test) {\n    test.clearBreakpoints();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport interface ChipTestInstruction extends TestInstruction {\n  _chipTestInstruction_: true;\n  do(test: ChipTest): void | Promise<void>;\n}\n\nexport class TestEvalInstruction implements ChipTestInstruction {\n  readonly _chipTestInstruction_ = true;\n  do(test: ChipTest) {\n    test.eval();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestTickInstruction implements ChipTestInstruction {\n  readonly _chipTestInstruction_ = true;\n  do(test: ChipTest) {\n    test.tick();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestTockInstruction implements ChipTestInstruction {\n  readonly _chipTestInstruction_ = true;\n  do(test: ChipTest) {\n    test.tock();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport interface CPUTestInstruction extends TestInstruction {\n  _cpuTestInstruction_: true;\n  do(test: CPUTest): void | Promise<void>;\n}\n\nexport class TestTickTockInstruction implements CPUTestInstruction {\n  readonly _cpuTestInstruction_ = true;\n  do(test: CPUTest) {\n    test.ticktock();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport interface VMTestInstruction extends TestInstruction {\n  _vmTestInstruction_: true;\n  do(test: VMTest): void | Promise<void>;\n}\n\nexport class TestVMStepInstruction implements VMTestInstruction {\n  readonly _vmTestInstruction_ = true;\n  do(test: VMTest) {\n    test.vmstep();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n"],"names":["DiffTable","className","out","cmp","zeroState","output","CMP","compare","isErr","_jsxs","children","_jsx","display","Err","cmpData","Ok","outData","failures","table","range","Math","min","length","map","i","cmpI","outI","max","_","j","cell","pass","trim","match","style","fontFamily","marginBottom","row","DiffCell","a","toString","isDisplay","str","JSON","stringify","emptyState","A","D","PC","ALU","flag","Flags","BITS","decode","instruction","bit","c","x1","x2","am","op","d1","d2","d3","j1","j2","j3","cpuTick","inM","bits","alu","cpuTock","reset","oldA","alu2","addressM","outM","writeM","CPU","RAM","ROM","Screen","Keyboard","state","this","setA","value","setD","setPC","constructor","RAMMem","SubMemory","SCREEN_SIZE","SCREEN_OFFSET","MemoryKeyboard","tick","input","tickState","_writeM","cpu","get","set","grammar","ohm","cmpGrammar","grammars","cmpSemantics","extendSemantics","baseSemantics","addAttribute","sourceString","line","_a","cells","_b","Root","lines","semantics","parser","parse","makeParser","tstGrammar","tstSemantics","extendAttribute","Index","idx","child","FileName","name","_open","dec","_close","OutputFormat","index","_c","id","lpad","width","rpad","builtin","undefined","address","TstEvalOperation","TstOutputOperation","TstOutputListOperation","formats","spec","n","format","TstSetOperation","setOp","TstEchoOperation","message","String","TstClearEchoOperation","TstLoadROMOperation","_r","_l","file","TstFileOperation","Condition","left","right","TstWhile","cond","_o","statements","statement","condition","span","start","source","startIdx","end","endIdx","TstRepeat","count","TstStatement","list","stmt","ops","asIteration","node","operation","break","Tst","tst","TST","Output","variable","fmt","lPad","rPad","len","startsWith","groups","parseInt","assert","includes","header","test","substring","padCenter","print","val","getVar","padLeft","B","bin","X","hex","padRight","slice","space","leftSpace","floor","rightSpace","padStart","padEnd","Test","instructions","_outputList","_log","fs","FileSystem","setFileSystem","echo","_content","clearEcho","async","_filename","outputFile","outputList","outputs","addInstruction","push","_steps","steps","_step","next","assertExists","currentStep","done","step","do","breakpoints","Map","addBreakpoint","clearBreakpoints","clear","values","join","log","isTstLineStatment","isTstWhileStatement","makeLineStatement","TestCompoundInstruction","inst","makeInstruction","TestTickInstruction","TestTockInstruction","TestTickTockInstruction","TestEvalInstruction","TestOutputInstruction","TestSetInstruction","TestOutputListInstruction","TestEchoInstruction","TestClearEchoInstruction","TestLoadROMInstruction","checkExhaustive","fill","repeat","TestWhileInstruction","TestRepeatInstruction","ChipTest","chip","Low","chipId","clock","Clock","static","with","hasVar","hasIn","hasOut","offset","pin","Bus","busVoltage","voltage","setVar","pinOrBus","pull","LOW","HIGH","eval","tock","filename","load","super","run","CPUTest","ticks","rom","Int16Array","ticktock","specs","addOutput","_test","innerSteps","x","y","check","content","pushd","popd","_chipTestInstruction_","_cpuTestInstruction_"],"sourceRoot":""}